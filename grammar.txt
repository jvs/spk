grammar spk

`from ast import literal_eval`

ignore Space = /[ \t]+/
ignore Comment = /#[^\r\n]*/
ignore LineExtension = /\.\.\.[ \t\r\n]+/

CheckedSpace = Backtrack(1) >> Space
ForbiddenSpace(x) = ExpectNot(CheckedSpace) >> x
RequiredSpace(x) = CheckedSpace >> x << CheckedSpace

Pad = /[ \t\r\n]+/*

wrap(x) => Pad >> (x) << Pad

# Allow "-" to appear in names. Use spaces around subtraction to disambiguate.
Word = /[_a-zA-Z][_a-zA-Z0-9\-]*/

# Parse a full word, then see if it matches our keyword. The point is to make
# sure that we don't simply match the first part of a word. (For example, if
# the input string is "notice", we wouldn't want to match the keyword "not".)
kw(word) => Word where `lambda x: x == word`

```
keywords = [
    'and',
    'else',
    'emit',
    'if',
    'match',
    'not',
    'on',
    'or',
    'press',
    'release',
    'return',
    'then',
    'to',
]
```

Name = Word where `lambda x: x not in keywords`

start = wrap(Lines(Definition | Globals | Template | Variable)) << ExpectNot(/./)


# Top-level definitions.

Definition = Class | Function | Graph | Node

class Class {
    pass kw("class")
    name: Opt(Name)
    parameters: Block(Parameter)
}

class Function {
    pass kw("function")
    name: Opt(Name)
    parameters: ParenthesesList(Parameter)
    returns: Opt(":" >> TypeExpression)
    body: Block(Statement)
}

class Graph {
    pass kw("graph")
    name: Opt(Name)
    body: Block(Config | Edges | Function | Node | State | Variable)
}

class Node {
    pass kw("node")
    name: Opt(Name)
    body: Block(Config | Function | Handler | State | Variable)
}

class Globals {
    pass kw("globals")
    name: Opt(Name)
    body: Block(Parameter)
}

class Template {
    pass kw("template")
    name: Name
    parameters: ParenthesesList(Parameter)
    returns: Opt(":" >> TypeExpression)
    body: Block(Statement)
}

class Variable {
    names: OptParenthesesList(AnnotatedName)
    value: "=" >> ValueExpression
}

class AnnotatedName {
    name: Name
    type: Opt(":" >> TypeExpression)
}

AnonymousDefinition = Definition where `lambda x: x.name is None`


## Elements of a graph.

class Edges {
    pass kw("edges")
    body: Block(ConditionalEdges | Edge)
}

class ConditionalEdges {
    pass kw("if")
    condition: ValueExpression
    body: Block(ConditionalEdges | Edge)
}

class Edge {
    nodes: Sep(Word, wrap(">>"), allow_empty=False)
}


## Elements of a node.

class Config {
    pass kw("config")
    name: Opt(Name)
    body: Block(Parameter)
}

class Handler {
    pass kw("on")
    action: Word
    parameters: ParenthesesList(Parameter)
    body: Block(Statement)
}

class State {
    pass kw("state")
    name: Opt(Name)
    body: Block(Parameter)
}


## Statements.

Statement = (
    Variable
    | Assign
    | Emit
    | For
    | Operate
    | Return
    | ValueExpression
)

class Assign {
    storage: OptParenthesesList(Storage)
    operator: (
        "="
        | "+="
        | "-="
        | "*="
        | "/="
        | "%="
        | "<<="
        | ">>="
        | "&="
        | "^="
        | "|="
    )
    value: ValueExpression
}

class Storage {
    target: ValueExpression
    type: Opt(":" >> TypeExpression)
}

class Emit {
    pass Opt("emit")
    key: ValueExpression
    target: Opt("to" >> ValueExpression)
}

class For {
    pass kw("for")
    storage: OptParenthesesList(Name)
    pass kw("in")
    source: ValueExpression
    guard: Opt(Pad >> kw("if") >> ValueExpression)
    body: Block(Statement)
}

class Operate {
    action: "press" | "release"
    key: ValueExpression
    target: Opt("to" >> ValueExpression)
}

class Return {
    pass kw("return")
    value: Opt(ValueExpression)
}


## Type-level expressions.

# Just use the same syntax as for values.
TypeExpression = ValueExpression


## Value-level expressions.

ValueExpression = (Reference | LiteralExpression | AnonymousDefinition) between {
    mixfix: "(" >> wrap(ValueExpression) << ")"
    postfix: ArgumentList, ElementAccess, FieldAccess, GenericArgumentList
    prefix: "-"
    left: "*", "/", "%"
    left: "+", "-"
    infix: wrap("<<"), wrap(">>")
    infix: "<=", ">=", RequiredSpace("<" | ">")
    infix: "in", NotIn
    infix: "==", "!="
    left: "&"
    left: "^"
    left: wrap("|")
    prefix: kw("not")
    left: wrap(kw("and"))
    left: wrap(kw("or"))
    mixfix: If, Match
}

NotIn = /not[ \t]+in/ >> `'not in'`

class Reference {
    name: Name
}

## Literal expressions.

LiteralExpression = (
    EmptyMapLiteral
    | ListLiteral
    | MapLiteral
    | NumberLiteral
    | SetLiteral
    | SymbolLiteral
    | TupleLiteral
)

class EmptyMapLiteral {
    pass "{" >> wrap(":") << "}"
}

class ListLiteral {
    elements: SquareList(ValueExpression)
}

class MapLiteral {
    pairs: CurlyList(Pair)
}

class Pair {
    key: ValueExpression
    value: ":" >> ValueExpression
}

class NumberLiteral {
    value: /\d+(\.\d*)?|\.\d+/
}

class SetLiteral {
    elements: CurlyList(ValueExpression)
}

class SymbolLiteral {
    contents: /"(?:[^\\"]|\\.)*"/ |> `literal_eval`
}

class TupleLiteral {
    pass "("
    elements: wrap(Sep(
        ValueExpression,
        Comma,
        allow_trailer=true,
        require_separator=true,
    ))
    pass ")"
}


## Postfix operators.

class ArgumentList {
    arguments: ParenthesesList(KeywordArgument(ValueExpression) | ValueExpression)
}

class GenericArgumentList {
    arguments: ForbiddenSpace("<") >> (GenericArgument /? Comma) << ForbiddenSpace(">")
}

GenericArgument = KeywordArgument(TypeExpression) | TypeExpression

class KeywordArgument(T) {
    name: Word
    pass "="
    value: T
}

class ElementAccess {
    indexes: SquareList(ValueExpression)
}

class FieldAccess {
    field: "." >> Word
}


## Mixfix operators.

class If {
    pass kw("if")
    condition: ValueExpression
    then_branch: Block(Statement)
    else_branch: Opt(kw("else") >> Block(Statement))
}

class Match {
    pass kw("match")
    value: ValueExpression
    cases: Block(MatchCase)
}

class MatchCase {
    pass kw("case")
    pattern: Opt(ValueExpression | "*")
    guard: Opt(kw("if") >> ValueExpression)
    body: Block(Statement)
}


## Common structures.

# TODO: Figure out why "wrap" doesn't work here.
Block(T) => Pad >> "{" >> Pad >> (T /? LineSep) << Pad << "}"

Comma = wrap(",")

LineSep = /[\n\r]+/+

Lines(T) = (T /? LineSep)

class Parameter {
    name: Name
    type: Opt(":" >> TypeExpression)
    default: Opt("=" >> ValueExpression)
}

OptParenthesesList(T) =>
    "(" >> T << ")"
    | ParenthesesList(T)
    | Sep(T, Comma, allow_empty=false, allow_trailer=true, require_separator=true)
    | T


### List structures.

# TODO: Figure out why "wrap" doesn't work here.
SurroundedList(L, T, R) => L >> Pad >> (T /? Comma) << Pad << R

CurlyList(T) => SurroundedList("{", T, "}")
ParenthesesList(T) => SurroundedList("(", T, ")")
SquareList(T) => SurroundedList("[", T, "]")
