# Generated by ../generate_parser.py
"""
# Grammar definition:
grammar spk

`from ast import literal_eval`

ignore Space = /[ \\t]+/
ignore Comment = /#[^\\r\\n]*/
ignore LineExtension = /\\.\\.\\.[ \\t\\r\\n]+/

Pad = /[ \\t\\r\\n]*/

wrap(x) => Pad >> x << Pad

# Allow "-" to appear in names. Use spaces around subtraction to disambiguate.
Word = /[_a-zA-Z][_a-zA-Z0-9\\-]*/

# Parse a full word, then see if it matches our keyword. The point is to make
# sure that we don't simply match the first part of a word. (For example, if
# the input string is "notice", we wouldn't want to match the keyword "not".)
kw(word) => Word where `lambda x: x == word`

```
keywords = [
    'and',
    'else',
    'if',
    'match',
    'not',
    'on',
    'or',
    'press',
    'release',
    'return',
    'then',
    'to',
]
```

Name = Word where `lambda x: x not in keywords`

start = wrap(Lines(Definition)) << ExpectNot(/./)


# Top-level definitions.

Definition = (
    Assign
    | Class
    | Function
    | Graph
    | Node
)

class Class {
    name: kw("class") >> Opt(Name)
    parameters: Block(Parameter)
}

class Function {
    name: kw("function") >> Opt(Name)
    parameters: ParenthesesList(Parameter)
    returns: Opt(":" >> TypeExpression)
    body: Block(Statement)
}

class Graph {
    name: kw("graph") >> Opt(Name)
    body: Block(Edges | Function | Node)
}

class Node {
    orientation: Lines(kw("input") | kw("output")) |> `set`
    name: Opt(kw("node")) >> Opt(Name)
    body: Block(Function | Handler | State)
}


## Elements of a graph.

Edges = kw("edges") >> Block(Edge)

class Edge {
    nodes: Sep(Word, ">>", allow_empty=False)
}


## Elements of a node.

class Handler {
    action: kw("on") >> Word
    parameters: ParenthesesList(Parameter)
    frequency: Opt("every" >> ValueExpression)
    body: Block(Statement)
}

class State {
    pass kw("state")
    body: Block(Parameter)
}


## Statements.

Statement = (
    Assign
    | Emit
    | Forward
    | Return
    | ValueExpression
)

class Assign {
    location: ValueExpression
    operator: (
        "="
        | "+="
        | "-="
        | "*="
        | "/="
        | "%="
        | "<<="
        | ">>="
        | "&="
        | "^="
        | "|="
    )
    value: ValueExpression
}

class Emit {
    action: "press" | "release"
    key: ValueExpression
    target: Opt("to" >> ValueExpression)
}

class Forward {
    key: ValueExpression
    target: "to" >> ValueExpression
}

class Return {
    value: kw("return") >> Opt(ValueExpression)
}


## Type-level expressions.

# Just use the same syntax as for values.
TypeExpression = ValueExpression


## Value-level expressions.

ValueExpression = (Name | LiteralExpression) between {
    mixfix: "(" >> Pad >> ValueExpression << Pad << ")"
    postfix: ArgumentList, ElementAccess, FieldAccess
    prefix: "-"
    left: "*", "/", "%"
    left: "+", "-"
    infix: wrap("<<"), wrap(">>")
    infix: "<=", "<", ">=", ">"
    infix: "==", "!="
    left: "&"
    left: "^"
    left: wrap("|")
    prefix: kw("not")
    left: wrap(kw("and"))
    left: wrap(kw("or"))
    mixfix: If, Match
}


## Literal expressions.

LiteralExpression = (
    EmptyMapLiteral
    | ListLiteral
    | MapLiteral
    | NumberLiteral
    | SetLiteral
    | StringLiteral
    | TupleLiteral
)

class EmptyMapLiteral {
    pass "{" >> Pad >> ":" << Pad << "}"
}

class ListLiteral {
    elements: SquareList(ValueExpression)
}

class MapLiteral {
    pairs: CurlyList(Pair)
}

class Pair {
    key: ValueExpression
    value: ":" >> ValueExpression
}

class NumberLiteral {
    value: /\\d+(\\.\\d*)?|\\.\\d+/
}

class SetLiteral {
    elements: CurlyList(ValueExpression)
}

class StringLiteral {
    contents: /"(?:[^\\\\"]|\\\\.)*"/ |> `literal_eval`
}

class TupleLiteral {
    pass "("
    elements: Sep(
        ValueExpression,
        Comma,
        allow_trailer=true,
        require_separator=true,
    )
    pass ")"
}


## Postfix operators.

class ArgumentList {
    arguments: ParenthesesList(ValueExpression)
}

class ElementAccess {
    index: "[" >> Pad >> Expr << Pad << "]"
}

class FieldAccess {
    field: "." >> Word
}


## Mixfix operators.

class If {
    condition: kw("if") >> ValueExpression
    then_branch: Block(Statement)
    else_branch: Opt(kw("else") >> Block(Statement))
}

class Match {
    value: kw("match") >> ValueExpression
    cases: Block(MatchCase)
}

class MatchCase {
    pattern: kw("case") >> (ValueExpression | "*")
    guard: Opt(kw("if") >> ValueExpression)
    body: Block(Statement)
}


## Common structures.

Block(T) => Pad >> "{" >> Pad >> (T /? LineSep) << Pad << "}"

Comma = wrap(",")

LineSep = /[\\n\\r]+/

Lines(T) = (T /? LineSep)

class Parameter {
    name: Name
    type: Opt(":" >> TypeExpression)
    default: Opt("=" >> ValueExpression)
}


### List structures.

SurroundedList(L, T, R) => L >> Pad >> (T /? Comma) << Pad << R

CurlyList(T) => SurroundedList("{", T, "}")
ParenthesesList(T) => SurroundedList("(", T, ")")
SquareList(T) => SurroundedList("[", T, "]")

"""

from collections import namedtuple as _nt
from re import compile as _compile_re, IGNORECASE as _IGNORECASE

class ParsedObject:
    _fields = ()

    def __init__(self):
        self._metadata = _Metadata()
        self._hash = None

    def __eq__(self, other):
        if self is other:
            return True
        if not isinstance(other, self.__class__):
            return False
        for field in self._fields:
            left = getattr(self, field)
            right = getattr(other, field)
            if left is not right and left != right:
                return False
        return True

    def __hash__(self):
        if self._hash is not None:
            return self._hash
        self._hash = 0
        result = 0
        for field in self._fields:
            result ^= _hash(getattr(self, field))
        self._hash = result
        return result

    def _asdict(self):
        return {k: getattr(self, k) for k in self._fields}

    def _replace(self, **kw):
        for field in self._fields:
            if field not in kw:
                kw[field] = getattr(self, field)
        result = self.__class__(**kw)
        result._metadata.update(self._metadata)
        return result


def _hash(value):
    try:
        return hash(value)
    except TypeError:
        if isinstance(value, (tuple, list)):
            result = 0
            for item in value:
                result ^= _hash(item)
            return result
        elif isinstance(value, dict):
            result = 0
            for pair in value.items():
                result ^= _hash(pair)
            return result
        else:
            raise


class _Metadata:
    def __init__(self, **fields):
        object.__setattr__(self, '_fields', fields)

    def __getattr__(self, name):
        return self._fields.get(name)

    def __setattr__(self, name, value):
        self._fields[name] = value

    def __len__(self):
        return len(self._fields)

    def copy(self):
        return _Metadata(**self._fields)

    def update(self, other):
        self._fields.update(other._fields)


class ParsingRule:
    def __init__(self, name, parse, definition):
        self.name = name
        self.parse = parse
        self.definition = definition

    def __repr__(self):
        return (f'ParsingRule(name={self.name!r}, parse={self.parse.__name__},'
            f' definition={self.definition!r})')


class _Context:
    pass

from ast import literal_eval

keywords = [
    'and',
    'else',
    'if',
    'match',
    'not',
    'on',
    'or',
    'press',
    'release',
    'return',
    'then',
    'to',
]


class InputError(Exception):
    """Common superclass for ParseError and PartialParseError."""


class ParseError(InputError):
    def __init__(self, message, index, line, column):
        super().__init__(message)
        self.position = _Position(index, line, column)


class PartialParseError(InputError):
    def __init__(self, partial_result, last_position, excerpt):
        super().__init__('Incomplete parse. Unexpected input on line'
            f' {last_position.line}, column {last_position.column}:\n{excerpt}')
        self.partial_result = partial_result
        self.last_position = last_position


class Infix(ParsedObject):
    _fields = ('left', 'operator', 'right')

    def __init__(self, left, operator, right):
        ParsedObject.__init__(self)
        self.left = left
        self.operator = operator
        self.right = right

    def __repr__(self):
        return f'Infix({self.left!r}, {self.operator!r}, {self.right!r})'


class Postfix(ParsedObject):
    _fields = ('left', 'operator')

    def __init__(self, left, operator):
        ParsedObject.__init__(self)
        self.left = left
        self.operator = operator

    def __repr__(self):
        return f'Postfix({self.left!r}, {self.operator!r})'


class Prefix(ParsedObject):
    _fields = ('operator', 'right')

    def __init__(self, operator, right):
        ParsedObject.__init__(self)
        self.operator = operator
        self.right = right

    def __repr__(self):
        return f'Prefix({self.operator!r}, {self.right!r})'


def parse(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_start, fullparse)


_PositionInfo = _nt('_PositionInfo', 'start, end')

_Position = _nt('_Position', 'index, line, column')


class _ParseFunction(_nt('_ParseFunction', 'func, args, kwargs')):
    def __call__(self, _ctx, _text, _pos):
        return self.func(_ctx, _text, _pos, *self.args, **dict(self.kwargs))


class _StringLiteral(str):
    def __call__(self, _ctx, _text, _pos):
        return self._parse_function(_ctx, _text, _pos)


def _wrap_string_literal(string_value, parse_function):
    result = _StringLiteral(string_value)
    result._parse_function = parse_function
    return result


class _ByteLiteral(int):
    def __call__(self, _ctx, _text, _pos):
        return self._parse_function(_ctx, _text, _pos)


def _wrap_byte_literal(byte_value, parse_function):
    result = _ByteLiteral(byte_value)
    result._parse_function = parse_function
    return result


def _run(_ctx, text, pos, start, fullparse):
    memo = {}
    result = None

    key = (3, start, pos)
    gtor = start(_ctx, text, pos)
    stack = [(key, gtor)]

    while stack:
        key, gtor = stack[-1]
        result = gtor.send(result)

        if result[0] != 3:
            stack.pop()
            memo[key] = result
        elif result in memo:
            result = memo[result]
        else:
            gtor = result[1](_ctx, text, result[2])
            stack.append((result, gtor))
            result = None

    if result[0]:
        return _finalize_parse_info(text, result[1], result[2], fullparse)
    else:
        pos = result[2]
        message = result[1](text, pos)
        raise ParseError(message, pos)


def visit(node):
    visited = set()
    stack = [node]
    while stack:
        node = stack.pop()

        if isinstance(node, (list, tuple)):
            stack.extend(reversed(node))

        elif isinstance(node, dict):
            stack.extend(reversed(node.values()))

        elif isinstance(node, ParsedObject):
            node_id = id(node)
            if node_id in visited:
                continue
            visited.add(node_id)

            yield node

            if hasattr(node, '_fields'):
                stack.extend(getattr(node, x) for x in reversed(node._fields))


_Traversing = _nt('_Traversing', 'parent, field, child, is_finished')


def traverse(node):
    visited = set()
    stack = [_Traversing(parent=None, field=None, child=node, is_finished=False)]
    while stack:
        traversing = stack.pop()

        if traversing.is_finished:
            yield traversing
            continue

        child = traversing.child
        child_id = id(child)

        if child_id in visited:
            continue

        visited.add(child_id)
        stack.append(traversing._replace(is_finished=True))
        yield traversing

        def extend(items):
            stack.extend(reversed(list(items)))

        if isinstance(child, (list, tuple)):
            extend(
                _Traversing(parent=child, field=i, child=x, is_finished=False)
                for i, x in enumerate(child)
            )

        elif isinstance(child, dict):
            extend(
                _Traversing(parent=child, field=k, child=v, is_finished=False)
                for k, v in child.items()
            )

        elif isinstance(child, ParsedObject) and hasattr(child, '_fields'):
            extend(
                _Traversing(
                    parent=child,
                    field=x,
                    child=getattr(child, x),
                    is_finished=False,
                )
                for x in child._fields
            )


def transform(node, *callbacks):
    if not callbacks:
        return node

    def callback(node):
        for f in callbacks:
            prev = node
            node = f(prev)

            if node is not prev:
                if (
                    isinstance(prev, ParsedObject)
                    and isinstance(node, ParsedObject)
                    and not node._metadata
                ):
                    node._metadata.update(prev._metadata)

        return node

    return _transform(node, callback)


def _transform(node, callback):
    if isinstance(node, list):
        return [_transform(x, callback) for x in node]

    if not isinstance(node, ParsedObject):
        return node

    updates = {}
    for field in node._fields:
        was = getattr(node, field)
        now = _transform(was, callback)
        if now is not was:
            updates[field] = now

    if updates:
        node = node._replace(**updates)

    return callback(node)


def _finalize_parse_info(text, nodes, pos, fullparse):
    line_numbers, column_numbers = _map_index_to_line_and_column(text)

    for node in visit(nodes):
        pos_info = node._metadata.position_info
        if pos_info:
            start, end = pos_info
            end -= 1
            node._metadata.position_info = _PositionInfo(
                start=_Position(start, line_numbers[start], column_numbers[start]),
                end=_Position(end, line_numbers[end], column_numbers[end]),
            )

    if fullparse and pos < len(text):
        line, col = line_numbers[pos], column_numbers[pos]
        position = _Position(pos, line, col)
        excerpt = _extract_excerpt(text, pos, col)
        raise PartialParseError(nodes, position, excerpt)

    return nodes


def _extract_excerpt(text, pos, col):
    if isinstance(text, bytes):
        return repr(text[max(0, pos - 1) : pos + 2])

    start = pos - (col - 1)
    match = _compile_re('\n').search(text, pos + 1)
    end = len(text) if match is None else match.start()

    if end - start < 96:
        return text[start : end] + _caret_at(col - 1)

    if col < 60:
        # Chop the line off at the end.
        return text[start : start + 90] + ' ...' + _caret_at(col - 1)

    elif end - pos < 40:
        # Chop the line off at the start.
        return '... ' + text[end - 90 : end] + _caret_at(pos - (end - 90) + 4)

    else:
        # Chop the line off at both ends.
        return '... ' + text[pos - 42 : pos + 42] + ' ...' + _caret_at(42 + 4)


def _caret_at(index):
    return '\n' + (' ' * index) + '^'


def _get_line_and_column(text, pos):
    line_numbers, column_numbers = _map_index_to_line_and_column(text)
    return line_numbers[pos], column_numbers[pos]


def _map_index_to_line_and_column(text):
    line_numbers = []
    column_numbers = []

    current_line = 1
    current_column = 0

    for c in text:
        if c == '\n':
            current_line += 1
            current_column = 0
        else:
            current_column += 1
        line_numbers.append(current_line)
        column_numbers.append(current_column)

    return line_numbers, column_numbers

matcher1 = _compile_re('[ \\t]+', flags=0).match
matcher2 = _compile_re('#[^\\r\\n]*', flags=0).match
matcher3 = _compile_re('\\.\\.\\.[ \\t\\r\\n]+', flags=0).match
matcher4 = _compile_re('[ \\t\\r\\n]*', flags=0).match
matcher5 = _compile_re('[_a-zA-Z][_a-zA-Z0-9\\-]*', flags=0).match
matcher6 = _compile_re('.', flags=0).match
matcher7 = _compile_re('\\d+(\\.\\d*)?|\\.\\d+', flags=0).match
matcher8 = _compile_re('"(?:[^\\\\"]|\\\\.)*"', flags=0).match
matcher9 = _compile_re('[\\n\\r]+', flags=0).match

def _try_Space(_ctx, _text, _pos):
    # Rule 'Space'
    # Begin Regex
    # /[ \\t]+/
    match1 = matcher1(_text, _pos)
    if match1:
        _result = match1.group(0)
        _pos = (yield (3, _ctx._try__ignored, match1.end()))[2]
        _status = True
    else:
        _result = _raise_error2
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_Space(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Space, fullparse)

Space = ParsingRule('Space', _parse_Space, """
    Space = /[ \\t]+/
""")
def _raise_error2(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Space' rule, at the expression:\n"
    '    /[ \\\\t]+/\n\n'
    'Expected to match the regular expression /[ \\t]+/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Comment(_ctx, _text, _pos):
    # Rule 'Comment'
    # Begin Regex
    # /#[^\\r\\n]*/
    match2 = matcher2(_text, _pos)
    if match2:
        _result = match2.group(0)
        _pos = (yield (3, _ctx._try__ignored, match2.end()))[2]
        _status = True
    else:
        _result = _raise_error4
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_Comment(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Comment, fullparse)

Comment = ParsingRule('Comment', _parse_Comment, """
    Comment = /#[^\\r\\n]*/
""")
def _raise_error4(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Comment' rule, at the expression:\n"
    '    /#[^\\\\r\\\\n]*/\n\n'
    'Expected to match the regular expression /#[^\\r\\n]*/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_LineExtension(_ctx, _text, _pos):
    # Rule 'LineExtension'
    # Begin Regex
    # /\\.\\.\\.[ \\t\\r\\n]+/
    match3 = matcher3(_text, _pos)
    if match3:
        _result = match3.group(0)
        _pos = (yield (3, _ctx._try__ignored, match3.end()))[2]
        _status = True
    else:
        _result = _raise_error6
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_LineExtension(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_LineExtension, fullparse)

LineExtension = ParsingRule('LineExtension', _parse_LineExtension, """
    LineExtension = /\\.\\.\\.[ \\t\\r\\n]+/
""")
def _raise_error6(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'LineExtension' rule, at the expression:\n"
    '    /\\\\.\\\\.\\\\.[ \\\\t\\\\r\\\\n]+/\n\n'
    'Expected to match the regular expression /\\.\\.\\.[ \\t\\r\\n]+/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Pad(_ctx, _text, _pos):
    # Rule 'Pad'
    # Begin Regex
    # /[ \\t\\r\\n]*/
    match4 = matcher4(_text, _pos)
    if match4:
        _result = match4.group(0)
        _pos = (yield (3, _ctx._try__ignored, match4.end()))[2]
        _status = True
    else:
        _result = _raise_error8
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_Pad(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Pad, fullparse)

Pad = ParsingRule('Pad', _parse_Pad, """
    Pad = /[ \\t\\r\\n]*/
""")
def _raise_error8(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Pad' rule, at the expression:\n"
    '    /[ \\\\t\\\\r\\\\n]*/\n\n'
    'Expected to match the regular expression /[ \\t\\r\\n]*/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_wrap(_ctx, _text, _pos, x):
    # Rule 'wrap'
    # Begin Discard
    # (Pad >> x) << Pad
    while True:
        # Begin Discard
        # Pad >> x
        while True:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
            # End Ref
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, x, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            break
        staging1 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
        # End Ref
        if _status:
            _result = staging1
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_wrap(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_wrap, fullparse)

wrap = ParsingRule('wrap', _parse_wrap, """
    wrap(x) = (Pad >> x) << Pad
""")
def _try_Word(_ctx, _text, _pos):
    # Rule 'Word'
    # Begin Regex
    # /[_a-zA-Z][_a-zA-Z0-9\\-]*/
    match5 = matcher5(_text, _pos)
    if match5:
        _result = match5.group(0)
        _pos = (yield (3, _ctx._try__ignored, match5.end()))[2]
        _status = True
    else:
        _result = _raise_error16
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_Word(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Word, fullparse)

Word = ParsingRule('Word', _parse_Word, """
    Word = /[_a-zA-Z][_a-zA-Z0-9\\-]*/
""")
def _raise_error16(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Word' rule, at the expression:\n"
    '    /[_a-zA-Z][_a-zA-Z0-9\\\\-]*/\n\n'
    'Expected to match the regular expression /[_a-zA-Z][_a-zA-Z0-9\\-]*/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_kw(_ctx, _text, _pos, word):
    # Rule 'kw'
    # Begin Where
    # Word where `lambda x: x == word`
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _ctx._try_Word, _pos))
    # End Ref
    if _status:
        arg1 = _result
        _result = lambda x: x == word
        _status = True
        if _result(arg1):
            _result = arg1
        else:
            _result = _raise_error18
            _status = False
    # End Where
    yield (_status, _result, _pos)

def _parse_kw(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_kw, fullparse)

kw = ParsingRule('kw', _parse_kw, """
    kw(word) = Word where `lambda x: x == word`
""")
def _raise_error18(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'kw' rule, at the expression:\n"
    '    Word where `lambda x: x == word`\n\n'
    'Expected to satisfy the predicate: `lambda x: x == word`'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Name(_ctx, _text, _pos):
    # Rule 'Name'
    # Begin Where
    # Word where `lambda x: x not in keywords`
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _ctx._try_Word, _pos))
    # End Ref
    if _status:
        arg2 = _result
        _result = lambda x: x not in keywords
        _status = True
        if _result(arg2):
            _result = arg2
        else:
            _result = _raise_error22
            _status = False
    # End Where
    yield (_status, _result, _pos)

def _parse_Name(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Name, fullparse)

Name = ParsingRule('Name', _parse_Name, """
    Name = Word where `lambda x: x not in keywords`
""")
def _raise_error22(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Name' rule, at the expression:\n"
    '    Word where `lambda x: x not in keywords`\n\n'
    'Expected to satisfy the predicate: `lambda x: x not in keywords`'
    )
    raise ParseError((title + details), _pos, line, col)

def _parse_function_31(_ctx, _text, _pos):
    # Begin Call
    # Lines(Definition)
    func1 = _ParseFunction(_ctx._try_Lines, (_try_Definition,), ())
    (_status, _result, _pos) = (yield (3, func1, _pos))
    # End Call
    yield (_status, _result, _pos)

def _try_start(_ctx, _text, _pos):
    # Rule 'start'
    # Begin Discard
    # _try__ignored >> (wrap(Lines(Definition)) << ExpectNot(/./))
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try__ignored, _pos))
        # End Ref
        if not (_status):
            break
        # Begin Discard
        # wrap(Lines(Definition)) << ExpectNot(/./)
        while True:
            # Begin Call
            # wrap(Lines(Definition))
            func2 = _ParseFunction(_ctx._try_wrap, (_parse_function_31,), ())
            (_status, _result, _pos) = (yield (3, func2, _pos))
            # End Call
            if not (_status):
                break
            staging2 = _result
            # Begin ExpectNot
            # ExpectNot(/./)
            backtrack1 = _pos
            # Begin Regex
            # /./
            match6 = matcher6(_text, _pos)
            if match6:
                _result = match6.group(0)
                _pos = (yield (3, _ctx._try__ignored, match6.end()))[2]
                _status = True
            else:
                _result = _raise_error35
                _status = False
            # End Regex
            _pos = backtrack1
            if _status:
                _status = False
                _result = _raise_error34
            else:
                _status = True
                _result = None
            # End ExpectNot
            if _status:
                _result = staging2
            break
        # End Discard
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_start(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_start, fullparse)

start = ParsingRule('start', _parse_start, """
    start = _try__ignored >> (wrap(Lines(Definition)) << ExpectNot(/./))
""")
def _raise_error34(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'start' rule, at the expression:\n"
    '    ExpectNot(/./)\n\n'
    'Did not expect to match: /./'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error35(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'start' rule, at the expression:\n"
    '    /./\n\n'
    'Expected to match the regular expression /./'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Definition(_ctx, _text, _pos):
    # Rule 'Definition'
    # Begin Choice
    farthest_err1 = _raise_error37
    backtrack2 = farthest_pos1 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Assign, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = backtrack2
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Class, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = backtrack2
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Function, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = backtrack2
        # Option 4:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Graph, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = backtrack2
        # Option 5:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Node, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = farthest_pos1
        _result = farthest_err1
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_Definition(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Definition, fullparse)

Definition = ParsingRule('Definition', _parse_Definition, """
    Definition = Assign | Class | Function | Graph | Node
""")
def _raise_error37(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Definition' rule, at the expression:\n"
    '    Assign | Class | Function | Graph | Node\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class Class(ParsedObject):
    """
    class Class {
        name: kw('class') >> Opt(Name)
        parameters: Block(Parameter)
    }
    """
    _fields = ('name', 'parameters')

    def __init__(self, name, parameters):
        ParsedObject.__init__(self)
        self.name = name
        self.parameters = parameters

    def __repr__(self):
        return f'Class(name={self.name!r}, parameters={self.parameters!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Class, fullparse)


def _parse_function_49(_ctx, _text, _pos):
    # Begin Str
    value1 = 'class'
    end1 = (_pos + 5)
    if (_text[slice(_pos, end1, None)] == value1):
        _result = value1
        _pos = (yield (3, _ctx._try__ignored, end1))[2]
        _status = True
    else:
        _result = _raise_error49
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Class(_ctx, _text, _pos):
    # Begin Seq
    start_pos1 = _pos
    while True:
        # Begin Discard
        # kw('class') >> Opt(Name)
        while True:
            # Begin Call
            # kw('class')
            arg3 = _wrap_string_literal('class', _parse_function_49)
            func3 = _ParseFunction(_ctx._try_kw, (arg3,), ())
            (_status, _result, _pos) = (yield (3, func3, _pos))
            # End Call
            if not (_status):
                break
            # Begin Opt
            # Opt(Name)
            backtrack3 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
            # End Ref
            if not (_status):
                _pos = backtrack3
                _result = None
                _status = True
            # End Opt
            break
        # End Discard
        if not (_status):
            break
        name = _result
        # Begin Call
        # Block(Parameter)
        func4 = _ParseFunction(_ctx._try_Block, (_try_Parameter,), ())
        (_status, _result, _pos) = (yield (3, func4, _pos))
        # End Call
        if not (_status):
            break
        parameters = _result
        _result = Class(name, parameters)
        _result._metadata.position_info = (start_pos1, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error49(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Class' rule, at the expression:\n"
    "    'class'\n\n"
    "Expected to match the string 'class'"
    )
    raise ParseError((title + details), _pos, line, col)

class Function(ParsedObject):
    """
    class Function {
        name: kw('function') >> Opt(Name)
        parameters: ParenthesesList(Parameter)
        returns: Opt(':' >> TypeExpression)
        body: Block(Statement)
    }
    """
    _fields = ('name', 'parameters', 'returns', 'body')

    def __init__(self, name, parameters, returns, body):
        ParsedObject.__init__(self)
        self.name = name
        self.parameters = parameters
        self.returns = returns
        self.body = body

    def __repr__(self):
        return f'Function(name={self.name!r}, parameters={self.parameters!r}, returns={self.returns!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Function, fullparse)


def _parse_function_62(_ctx, _text, _pos):
    # Begin Str
    value2 = 'function'
    end2 = (_pos + 8)
    if (_text[slice(_pos, end2, None)] == value2):
        _result = value2
        _pos = (yield (3, _ctx._try__ignored, end2))[2]
        _status = True
    else:
        _result = _raise_error62
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Function(_ctx, _text, _pos):
    # Begin Seq
    start_pos2 = _pos
    while True:
        # Begin Discard
        # kw('function') >> Opt(Name)
        while True:
            # Begin Call
            # kw('function')
            arg4 = _wrap_string_literal('function', _parse_function_62)
            func5 = _ParseFunction(_ctx._try_kw, (arg4,), ())
            (_status, _result, _pos) = (yield (3, func5, _pos))
            # End Call
            if not (_status):
                break
            # Begin Opt
            # Opt(Name)
            backtrack4 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
            # End Ref
            if not (_status):
                _pos = backtrack4
                _result = None
                _status = True
            # End Opt
            break
        # End Discard
        if not (_status):
            break
        name = _result
        # Begin Call
        # ParenthesesList(Parameter)
        func6 = _ParseFunction(_ctx._try_ParenthesesList, (_try_Parameter,), ())
        (_status, _result, _pos) = (yield (3, func6, _pos))
        # End Call
        if not (_status):
            break
        parameters = _result
        # Begin Opt
        # Opt(':' >> TypeExpression)
        backtrack5 = _pos
        # Begin Discard
        # ':' >> TypeExpression
        while True:
            # Begin Str
            value3 = ':'
            end3 = (_pos + 1)
            if (_text[slice(_pos, end3, None)] == value3):
                _result = value3
                _pos = (yield (3, _ctx._try__ignored, end3))[2]
                _status = True
            else:
                _result = _raise_error72
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_TypeExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack5
            _result = None
            _status = True
        # End Opt
        returns = _result
        # Begin Call
        # Block(Statement)
        func7 = _ParseFunction(_ctx._try_Block, (_try_Statement,), ())
        (_status, _result, _pos) = (yield (3, func7, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = Function(name, parameters, returns, body)
        _result._metadata.position_info = (start_pos2, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error62(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Function' rule, at the expression:\n"
    "    'function'\n\n"
    "Expected to match the string 'function'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error72(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Function' rule, at the expression:\n"
    "    ':'\n\n"
    "Expected to match the string ':'"
    )
    raise ParseError((title + details), _pos, line, col)

class Graph(ParsedObject):
    """
    class Graph {
        name: kw('graph') >> Opt(Name)
        body: Block(Edges | Function | Node)
    }
    """
    _fields = ('name', 'body')

    def __init__(self, name, body):
        ParsedObject.__init__(self)
        self.name = name
        self.body = body

    def __repr__(self):
        return f'Graph(name={self.name!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Graph, fullparse)


def _parse_function_84(_ctx, _text, _pos):
    # Begin Str
    value4 = 'graph'
    end4 = (_pos + 5)
    if (_text[slice(_pos, end4, None)] == value4):
        _result = value4
        _pos = (yield (3, _ctx._try__ignored, end4))[2]
        _status = True
    else:
        _result = _raise_error84
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_90(_ctx, _text, _pos):
    # Begin Choice
    farthest_err2 = _raise_error90
    backtrack7 = farthest_pos2 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Edges, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos2 < _pos):
            farthest_pos2 = _pos
            farthest_err2 = _result
        _pos = backtrack7
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Function, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos2 < _pos):
            farthest_pos2 = _pos
            farthest_err2 = _result
        _pos = backtrack7
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Node, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos2 < _pos):
            farthest_pos2 = _pos
            farthest_err2 = _result
        _pos = farthest_pos2
        _result = farthest_err2
        break
    # End Choice
    yield (_status, _result, _pos)

def _try_Graph(_ctx, _text, _pos):
    # Begin Seq
    start_pos3 = _pos
    while True:
        # Begin Discard
        # kw('graph') >> Opt(Name)
        while True:
            # Begin Call
            # kw('graph')
            arg5 = _wrap_string_literal('graph', _parse_function_84)
            func8 = _ParseFunction(_ctx._try_kw, (arg5,), ())
            (_status, _result, _pos) = (yield (3, func8, _pos))
            # End Call
            if not (_status):
                break
            # Begin Opt
            # Opt(Name)
            backtrack6 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
            # End Ref
            if not (_status):
                _pos = backtrack6
                _result = None
                _status = True
            # End Opt
            break
        # End Discard
        if not (_status):
            break
        name = _result
        # Begin Call
        # Block(Edges | Function | Node)
        func9 = _ParseFunction(_ctx._try_Block, (_parse_function_90,), ())
        (_status, _result, _pos) = (yield (3, func9, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = Graph(name, body)
        _result._metadata.position_info = (start_pos3, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error84(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Graph' rule, at the expression:\n"
    "    'graph'\n\n"
    "Expected to match the string 'graph'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error90(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Graph' rule, at the expression:\n"
    '    Edges | Function | Node\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class Node(ParsedObject):
    """
    class Node {
        orientation: Lines(kw('input') | kw('output')) |> `set`
        name: Opt(kw('node')) >> Opt(Name)
        body: Block(Function | Handler | State)
    }
    """
    _fields = ('orientation', 'name', 'body')

    def __init__(self, orientation, name, body):
        ParsedObject.__init__(self)
        self.orientation = orientation
        self.name = name
        self.body = body

    def __repr__(self):
        return f'Node(orientation={self.orientation!r}, name={self.name!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Node, fullparse)


def _parse_function_103(_ctx, _text, _pos):
    # Begin Str
    value5 = 'input'
    end5 = (_pos + 5)
    if (_text[slice(_pos, end5, None)] == value5):
        _result = value5
        _pos = (yield (3, _ctx._try__ignored, end5))[2]
        _status = True
    else:
        _result = _raise_error103
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_106(_ctx, _text, _pos):
    # Begin Str
    value6 = 'output'
    end6 = (_pos + 6)
    if (_text[slice(_pos, end6, None)] == value6):
        _result = value6
        _pos = (yield (3, _ctx._try__ignored, end6))[2]
        _status = True
    else:
        _result = _raise_error106
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_100(_ctx, _text, _pos):
    # Begin Choice
    farthest_err3 = _raise_error100
    backtrack8 = farthest_pos3 = _pos
    while True:
        # Option 1:
        # Begin Call
        # kw('input')
        arg6 = _wrap_string_literal('input', _parse_function_103)
        func10 = _ParseFunction(_ctx._try_kw, (arg6,), ())
        (_status, _result, _pos) = (yield (3, func10, _pos))
        # End Call
        if _status:
            break
        if (farthest_pos3 < _pos):
            farthest_pos3 = _pos
            farthest_err3 = _result
        _pos = backtrack8
        # Option 2:
        # Begin Call
        # kw('output')
        arg7 = _wrap_string_literal('output', _parse_function_106)
        func11 = _ParseFunction(_ctx._try_kw, (arg7,), ())
        (_status, _result, _pos) = (yield (3, func11, _pos))
        # End Call
        if _status:
            break
        if (farthest_pos3 < _pos):
            farthest_pos3 = _pos
            farthest_err3 = _result
        _pos = farthest_pos3
        _result = farthest_err3
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_function_113(_ctx, _text, _pos):
    # Begin Str
    value7 = 'node'
    end7 = (_pos + 4)
    if (_text[slice(_pos, end7, None)] == value7):
        _result = value7
        _pos = (yield (3, _ctx._try__ignored, end7))[2]
        _status = True
    else:
        _result = _raise_error113
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_119(_ctx, _text, _pos):
    # Begin Choice
    farthest_err4 = _raise_error119
    backtrack11 = farthest_pos4 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Function, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack11
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Handler, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack11
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_State, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = farthest_pos4
        _result = farthest_err4
        break
    # End Choice
    yield (_status, _result, _pos)

def _try_Node(_ctx, _text, _pos):
    # Begin Seq
    start_pos4 = _pos
    while True:
        # Begin Apply
        # Lines(kw('input') | kw('output')) |> `set`
        # Begin Call
        # Lines(kw('input') | kw('output'))
        func12 = _ParseFunction(_ctx._try_Lines, (_parse_function_100,), ())
        (_status, _result, _pos) = (yield (3, func12, _pos))
        # End Call
        if _status:
            arg8 = _result
            _result = set
            _status = True
            _result = _result(arg8)
        # End Apply
        if not (_status):
            break
        orientation = _result
        # Begin Discard
        # Opt(kw('node')) >> Opt(Name)
        while True:
            # Begin Opt
            # Opt(kw('node'))
            backtrack9 = _pos
            # Begin Call
            # kw('node')
            arg9 = _wrap_string_literal('node', _parse_function_113)
            func13 = _ParseFunction(_ctx._try_kw, (arg9,), ())
            (_status, _result, _pos) = (yield (3, func13, _pos))
            # End Call
            if not (_status):
                _pos = backtrack9
                _result = None
                _status = True
            # End Opt
            # Begin Opt
            # Opt(Name)
            backtrack10 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
            # End Ref
            if not (_status):
                _pos = backtrack10
                _result = None
                _status = True
            # End Opt
            break
        # End Discard
        name = _result
        # Begin Call
        # Block(Function | Handler | State)
        func14 = _ParseFunction(_ctx._try_Block, (_parse_function_119,), ())
        (_status, _result, _pos) = (yield (3, func14, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = Node(orientation, name, body)
        _result._metadata.position_info = (start_pos4, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error100(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Node' rule, at the expression:\n"
    "    kw('input') | kw('output')\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error103(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Node' rule, at the expression:\n"
    "    'input'\n\n"
    "Expected to match the string 'input'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error106(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Node' rule, at the expression:\n"
    "    'output'\n\n"
    "Expected to match the string 'output'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error113(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Node' rule, at the expression:\n"
    "    'node'\n\n"
    "Expected to match the string 'node'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error119(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Node' rule, at the expression:\n"
    '    Function | Handler | State\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _parse_function_127(_ctx, _text, _pos):
    # Begin Str
    value8 = 'edges'
    end8 = (_pos + 5)
    if (_text[slice(_pos, end8, None)] == value8):
        _result = value8
        _pos = (yield (3, _ctx._try__ignored, end8))[2]
        _status = True
    else:
        _result = _raise_error127
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Edges(_ctx, _text, _pos):
    # Rule 'Edges'
    # Begin Discard
    # kw('edges') >> Block(Edge)
    while True:
        # Begin Call
        # kw('edges')
        arg10 = _wrap_string_literal('edges', _parse_function_127)
        func15 = _ParseFunction(_ctx._try_kw, (arg10,), ())
        (_status, _result, _pos) = (yield (3, func15, _pos))
        # End Call
        if not (_status):
            break
        # Begin Call
        # Block(Edge)
        func16 = _ParseFunction(_ctx._try_Block, (_try_Edge,), ())
        (_status, _result, _pos) = (yield (3, func16, _pos))
        # End Call
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_Edges(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Edges, fullparse)

Edges = ParsingRule('Edges', _parse_Edges, """
    Edges = kw('edges') >> Block(Edge)
""")
def _raise_error127(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Edges' rule, at the expression:\n"
    "    'edges'\n\n"
    "Expected to match the string 'edges'"
    )
    raise ParseError((title + details), _pos, line, col)

class Edge(ParsedObject):
    """
    class Edge {
        nodes: Sep(Word, '>>', allow_trailer=False, allow_empty=False)
    }
    """
    _fields = ('nodes',)

    def __init__(self, nodes):
        ParsedObject.__init__(self)
        self.nodes = nodes

    def __repr__(self):
        return f'Edge(nodes={self.nodes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Edge, fullparse)


def _try_Edge(_ctx, _text, _pos):
    # Begin Seq
    start_pos5 = _pos
    while True:
        # Begin Sep
        # Sep(Word, '>>', allow_trailer=False, allow_empty=False)
        staging3 = []
        checkpoint1 = _pos
        while True:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Word, _pos))
            # End Ref
            if not (_status):
                break
            staging3.append(_result)
            checkpoint1 = _pos
            # Begin Str
            value9 = '>>'
            end9 = (_pos + 2)
            if (_text[slice(_pos, end9, None)] == value9):
                _result = value9
                _pos = (yield (3, _ctx._try__ignored, end9))[2]
                _status = True
            else:
                _result = _raise_error136
                _status = False
            # End Str
            if not (_status):
                break
        if staging3:
            _result = staging3
            _pos = checkpoint1
            _status = True
        # End Sep
        if not (_status):
            break
        nodes = _result
        _result = Edge(nodes)
        _result._metadata.position_info = (start_pos5, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error136(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Edge' rule, at the expression:\n"
    "    '>>'\n\n"
    "Expected to match the string '>>'"
    )
    raise ParseError((title + details), _pos, line, col)

class Handler(ParsedObject):
    """
    class Handler {
        action: kw('on') >> Word
        parameters: ParenthesesList(Parameter)
        frequency: Opt('every' >> ValueExpression)
        body: Block(Statement)
    }
    """
    _fields = ('action', 'parameters', 'frequency', 'body')

    def __init__(self, action, parameters, frequency, body):
        ParsedObject.__init__(self)
        self.action = action
        self.parameters = parameters
        self.frequency = frequency
        self.body = body

    def __repr__(self):
        return f'Handler(action={self.action!r}, parameters={self.parameters!r}, frequency={self.frequency!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Handler, fullparse)


def _parse_function_143(_ctx, _text, _pos):
    # Begin Str
    value10 = 'on'
    end10 = (_pos + 2)
    if (_text[slice(_pos, end10, None)] == value10):
        _result = value10
        _pos = (yield (3, _ctx._try__ignored, end10))[2]
        _status = True
    else:
        _result = _raise_error143
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Handler(_ctx, _text, _pos):
    # Begin Seq
    start_pos6 = _pos
    while True:
        # Begin Discard
        # kw('on') >> Word
        while True:
            # Begin Call
            # kw('on')
            arg11 = _wrap_string_literal('on', _parse_function_143)
            func17 = _ParseFunction(_ctx._try_kw, (arg11,), ())
            (_status, _result, _pos) = (yield (3, func17, _pos))
            # End Call
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Word, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            break
        action = _result
        # Begin Call
        # ParenthesesList(Parameter)
        func18 = _ParseFunction(_ctx._try_ParenthesesList, (_try_Parameter,), ())
        (_status, _result, _pos) = (yield (3, func18, _pos))
        # End Call
        if not (_status):
            break
        parameters = _result
        # Begin Opt
        # Opt('every' >> ValueExpression)
        backtrack12 = _pos
        # Begin Discard
        # 'every' >> ValueExpression
        while True:
            # Begin Str
            value11 = 'every'
            end11 = (_pos + 5)
            if (_text[slice(_pos, end11, None)] == value11):
                _result = value11
                _pos = (yield (3, _ctx._try__ignored, end11))[2]
                _status = True
            else:
                _result = _raise_error152
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack12
            _result = None
            _status = True
        # End Opt
        frequency = _result
        # Begin Call
        # Block(Statement)
        func19 = _ParseFunction(_ctx._try_Block, (_try_Statement,), ())
        (_status, _result, _pos) = (yield (3, func19, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = Handler(action, parameters, frequency, body)
        _result._metadata.position_info = (start_pos6, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error143(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Handler' rule, at the expression:\n"
    "    'on'\n\n"
    "Expected to match the string 'on'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error152(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Handler' rule, at the expression:\n"
    "    'every'\n\n"
    "Expected to match the string 'every'"
    )
    raise ParseError((title + details), _pos, line, col)

class State(ParsedObject):
    """
    class State {
        pass kw('state')
        body: Block(Parameter)
    }
    """
    _fields = ('body',)

    def __init__(self, body):
        ParsedObject.__init__(self)
        self.body = body

    def __repr__(self):
        return f'State(body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_State, fullparse)


def _parse_function_163(_ctx, _text, _pos):
    # Begin Str
    value12 = 'state'
    end12 = (_pos + 5)
    if (_text[slice(_pos, end12, None)] == value12):
        _result = value12
        _pos = (yield (3, _ctx._try__ignored, end12))[2]
        _status = True
    else:
        _result = _raise_error163
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_State(_ctx, _text, _pos):
    # Begin Seq
    start_pos7 = _pos
    while True:
        # Begin Call
        # kw('state')
        arg12 = _wrap_string_literal('state', _parse_function_163)
        func20 = _ParseFunction(_ctx._try_kw, (arg12,), ())
        (_status, _result, _pos) = (yield (3, func20, _pos))
        # End Call
        if not (_status):
            break
        item1 = _result
        # Begin Call
        # Block(Parameter)
        func21 = _ParseFunction(_ctx._try_Block, (_try_Parameter,), ())
        (_status, _result, _pos) = (yield (3, func21, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = State(body)
        _result._metadata.position_info = (start_pos7, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error163(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'State' rule, at the expression:\n"
    "    'state'\n\n"
    "Expected to match the string 'state'"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Statement(_ctx, _text, _pos):
    # Rule 'Statement'
    # Begin Choice
    farthest_err5 = _raise_error169
    backtrack13 = farthest_pos5 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Assign, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos5 < _pos):
            farthest_pos5 = _pos
            farthest_err5 = _result
        _pos = backtrack13
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Emit, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos5 < _pos):
            farthest_pos5 = _pos
            farthest_err5 = _result
        _pos = backtrack13
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Forward, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos5 < _pos):
            farthest_pos5 = _pos
            farthest_err5 = _result
        _pos = backtrack13
        # Option 4:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Return, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos5 < _pos):
            farthest_pos5 = _pos
            farthest_err5 = _result
        _pos = backtrack13
        # Option 5:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos5 < _pos):
            farthest_pos5 = _pos
            farthest_err5 = _result
        _pos = farthest_pos5
        _result = farthest_err5
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_Statement(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Statement, fullparse)

Statement = ParsingRule('Statement', _parse_Statement, """
    Statement = Assign | Emit | Forward | Return | ValueExpression
""")
def _raise_error169(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Statement' rule, at the expression:\n"
    '    Assign | Emit | Forward | Return | ValueExpression\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class Assign(ParsedObject):
    """
    class Assign {
        location: ValueExpression
        operator: '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '^=' | '|='
        value: ValueExpression
    }
    """
    _fields = ('location', 'operator', 'value')

    def __init__(self, location, operator, value):
        ParsedObject.__init__(self)
        self.location = location
        self.operator = operator
        self.value = value

    def __repr__(self):
        return f'Assign(location={self.location!r}, operator={self.operator!r}, value={self.value!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Assign, fullparse)


def _try_Assign(_ctx, _text, _pos):
    # Begin Seq
    start_pos8 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        location = _result
        # Begin Choice
        farthest_err6 = _raise_error180
        farthest_pos6 = _pos
        while True:
            # Option 1:
            # Begin Str
            value13 = '='
            end13 = (_pos + 1)
            if (_text[slice(_pos, end13, None)] == value13):
                _result = value13
                _pos = (yield (3, _ctx._try__ignored, end13))[2]
                _status = True
            else:
                _result = _raise_error181
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Str
            value14 = '+='
            end14 = (_pos + 2)
            if (_text[slice(_pos, end14, None)] == value14):
                _result = value14
                _pos = (yield (3, _ctx._try__ignored, end14))[2]
                _status = True
            else:
                _result = _raise_error182
                _status = False
            # End Str
            if _status:
                break
            # Option 3:
            # Begin Str
            value15 = '-='
            end15 = (_pos + 2)
            if (_text[slice(_pos, end15, None)] == value15):
                _result = value15
                _pos = (yield (3, _ctx._try__ignored, end15))[2]
                _status = True
            else:
                _result = _raise_error183
                _status = False
            # End Str
            if _status:
                break
            # Option 4:
            # Begin Str
            value16 = '*='
            end16 = (_pos + 2)
            if (_text[slice(_pos, end16, None)] == value16):
                _result = value16
                _pos = (yield (3, _ctx._try__ignored, end16))[2]
                _status = True
            else:
                _result = _raise_error184
                _status = False
            # End Str
            if _status:
                break
            # Option 5:
            # Begin Str
            value17 = '/='
            end17 = (_pos + 2)
            if (_text[slice(_pos, end17, None)] == value17):
                _result = value17
                _pos = (yield (3, _ctx._try__ignored, end17))[2]
                _status = True
            else:
                _result = _raise_error185
                _status = False
            # End Str
            if _status:
                break
            # Option 6:
            # Begin Str
            value18 = '%='
            end18 = (_pos + 2)
            if (_text[slice(_pos, end18, None)] == value18):
                _result = value18
                _pos = (yield (3, _ctx._try__ignored, end18))[2]
                _status = True
            else:
                _result = _raise_error186
                _status = False
            # End Str
            if _status:
                break
            # Option 7:
            # Begin Str
            value19 = '<<='
            end19 = (_pos + 3)
            if (_text[slice(_pos, end19, None)] == value19):
                _result = value19
                _pos = (yield (3, _ctx._try__ignored, end19))[2]
                _status = True
            else:
                _result = _raise_error187
                _status = False
            # End Str
            if _status:
                break
            # Option 8:
            # Begin Str
            value20 = '>>='
            end20 = (_pos + 3)
            if (_text[slice(_pos, end20, None)] == value20):
                _result = value20
                _pos = (yield (3, _ctx._try__ignored, end20))[2]
                _status = True
            else:
                _result = _raise_error188
                _status = False
            # End Str
            if _status:
                break
            # Option 9:
            # Begin Str
            value21 = '&='
            end21 = (_pos + 2)
            if (_text[slice(_pos, end21, None)] == value21):
                _result = value21
                _pos = (yield (3, _ctx._try__ignored, end21))[2]
                _status = True
            else:
                _result = _raise_error189
                _status = False
            # End Str
            if _status:
                break
            # Option 10:
            # Begin Str
            value22 = '^='
            end22 = (_pos + 2)
            if (_text[slice(_pos, end22, None)] == value22):
                _result = value22
                _pos = (yield (3, _ctx._try__ignored, end22))[2]
                _status = True
            else:
                _result = _raise_error190
                _status = False
            # End Str
            if _status:
                break
            # Option 11:
            # Begin Str
            value23 = '|='
            end23 = (_pos + 2)
            if (_text[slice(_pos, end23, None)] == value23):
                _result = value23
                _pos = (yield (3, _ctx._try__ignored, end23))[2]
                _status = True
            else:
                _result = _raise_error191
                _status = False
            # End Str
            if _status:
                break
            _pos = farthest_pos6
            _result = farthest_err6
            break
        # End Choice
        if not (_status):
            break
        operator = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        value = _result
        _result = Assign(location, operator, value)
        _result._metadata.position_info = (start_pos8, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error180(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '^=' | '|='\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error181(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '='\n\n"
    "Expected to match the string '='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error182(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '+='\n\n"
    "Expected to match the string '+='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error183(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '-='\n\n"
    "Expected to match the string '-='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error184(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '*='\n\n"
    "Expected to match the string '*='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error185(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '/='\n\n"
    "Expected to match the string '/='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error186(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '%='\n\n"
    "Expected to match the string '%='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error187(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '<<='\n\n"
    "Expected to match the string '<<='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error188(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '>>='\n\n"
    "Expected to match the string '>>='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error189(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '&='\n\n"
    "Expected to match the string '&='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error190(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '^='\n\n"
    "Expected to match the string '^='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error191(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '|='\n\n"
    "Expected to match the string '|='"
    )
    raise ParseError((title + details), _pos, line, col)

class Emit(ParsedObject):
    """
    class Emit {
        action: 'press' | 'release'
        key: ValueExpression
        target: Opt('to' >> ValueExpression)
    }
    """
    _fields = ('action', 'key', 'target')

    def __init__(self, action, key, target):
        ParsedObject.__init__(self)
        self.action = action
        self.key = key
        self.target = target

    def __repr__(self):
        return f'Emit(action={self.action!r}, key={self.key!r}, target={self.target!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Emit, fullparse)


def _try_Emit(_ctx, _text, _pos):
    # Begin Seq
    start_pos9 = _pos
    while True:
        # Begin Choice
        farthest_err7 = _raise_error197
        farthest_pos7 = _pos
        while True:
            # Option 1:
            # Begin Str
            value24 = 'press'
            end24 = (_pos + 5)
            if (_text[slice(_pos, end24, None)] == value24):
                _result = value24
                _pos = (yield (3, _ctx._try__ignored, end24))[2]
                _status = True
            else:
                _result = _raise_error198
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Str
            value25 = 'release'
            end25 = (_pos + 7)
            if (_text[slice(_pos, end25, None)] == value25):
                _result = value25
                _pos = (yield (3, _ctx._try__ignored, end25))[2]
                _status = True
            else:
                _result = _raise_error199
                _status = False
            # End Str
            if _status:
                break
            _pos = farthest_pos7
            _result = farthest_err7
            break
        # End Choice
        if not (_status):
            break
        action = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        key = _result
        # Begin Opt
        # Opt('to' >> ValueExpression)
        backtrack14 = _pos
        # Begin Discard
        # 'to' >> ValueExpression
        while True:
            # Begin Str
            value26 = 'to'
            end26 = (_pos + 2)
            if (_text[slice(_pos, end26, None)] == value26):
                _result = value26
                _pos = (yield (3, _ctx._try__ignored, end26))[2]
                _status = True
            else:
                _result = _raise_error205
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack14
            _result = None
            _status = True
        # End Opt
        target = _result
        _result = Emit(action, key, target)
        _result._metadata.position_info = (start_pos9, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error197(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Emit' rule, at the expression:\n"
    "    'press' | 'release'\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error198(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Emit' rule, at the expression:\n"
    "    'press'\n\n"
    "Expected to match the string 'press'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error199(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Emit' rule, at the expression:\n"
    "    'release'\n\n"
    "Expected to match the string 'release'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error205(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Emit' rule, at the expression:\n"
    "    'to'\n\n"
    "Expected to match the string 'to'"
    )
    raise ParseError((title + details), _pos, line, col)

class Forward(ParsedObject):
    """
    class Forward {
        key: ValueExpression
        target: 'to' >> ValueExpression
    }
    """
    _fields = ('key', 'target')

    def __init__(self, key, target):
        ParsedObject.__init__(self)
        self.key = key
        self.target = target

    def __repr__(self):
        return f'Forward(key={self.key!r}, target={self.target!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Forward, fullparse)


def _try_Forward(_ctx, _text, _pos):
    # Begin Seq
    start_pos10 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        key = _result
        # Begin Discard
        # 'to' >> ValueExpression
        while True:
            # Begin Str
            value27 = 'to'
            end27 = (_pos + 2)
            if (_text[slice(_pos, end27, None)] == value27):
                _result = value27
                _pos = (yield (3, _ctx._try__ignored, end27))[2]
                _status = True
            else:
                _result = _raise_error213
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            break
        target = _result
        _result = Forward(key, target)
        _result._metadata.position_info = (start_pos10, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error213(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Forward' rule, at the expression:\n"
    "    'to'\n\n"
    "Expected to match the string 'to'"
    )
    raise ParseError((title + details), _pos, line, col)

class Return(ParsedObject):
    """
    class Return {
        value: kw('return') >> Opt(ValueExpression)
    }
    """
    _fields = ('value',)

    def __init__(self, value):
        ParsedObject.__init__(self)
        self.value = value

    def __repr__(self):
        return f'Return(value={self.value!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Return, fullparse)


def _parse_function_221(_ctx, _text, _pos):
    # Begin Str
    value28 = 'return'
    end28 = (_pos + 6)
    if (_text[slice(_pos, end28, None)] == value28):
        _result = value28
        _pos = (yield (3, _ctx._try__ignored, end28))[2]
        _status = True
    else:
        _result = _raise_error221
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Return(_ctx, _text, _pos):
    # Begin Seq
    start_pos11 = _pos
    while True:
        # Begin Discard
        # kw('return') >> Opt(ValueExpression)
        while True:
            # Begin Call
            # kw('return')
            arg13 = _wrap_string_literal('return', _parse_function_221)
            func22 = _ParseFunction(_ctx._try_kw, (arg13,), ())
            (_status, _result, _pos) = (yield (3, func22, _pos))
            # End Call
            if not (_status):
                break
            # Begin Opt
            # Opt(ValueExpression)
            backtrack15 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            if not (_status):
                _pos = backtrack15
                _result = None
                _status = True
            # End Opt
            break
        # End Discard
        if not (_status):
            break
        value = _result
        _result = Return(value)
        _result._metadata.position_info = (start_pos11, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error221(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Return' rule, at the expression:\n"
    "    'return'\n\n"
    "Expected to match the string 'return'"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_TypeExpression(_ctx, _text, _pos):
    # Rule 'TypeExpression'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_TypeExpression(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_TypeExpression, fullparse)

TypeExpression = ParsingRule('TypeExpression', _parse_TypeExpression, """
    TypeExpression = ValueExpression
""")
def _parse_function_235(_ctx, _text, _pos):
    # Begin Str
    value30 = 'not'
    end30 = (_pos + 3)
    if (_text[slice(_pos, end30, None)] == value30):
        _result = value30
        _pos = (yield (3, _ctx._try__ignored, end30))[2]
        _status = True
    else:
        _result = _raise_error235
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_275(_ctx, _text, _pos):
    # Begin Str
    value38 = '<<'
    end38 = (_pos + 2)
    if (_text[slice(_pos, end38, None)] == value38):
        _result = value38
        _pos = (yield (3, _ctx._try__ignored, end38))[2]
        _status = True
    else:
        _result = _raise_error275
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_278(_ctx, _text, _pos):
    # Begin Str
    value39 = '>>'
    end39 = (_pos + 2)
    if (_text[slice(_pos, end39, None)] == value39):
        _result = value39
        _pos = (yield (3, _ctx._try__ignored, end39))[2]
        _status = True
    else:
        _result = _raise_error278
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_301(_ctx, _text, _pos):
    # Begin Str
    value48 = '|'
    end48 = (_pos + 1)
    if (_text[slice(_pos, end48, None)] == value48):
        _result = value48
        _pos = (yield (3, _ctx._try__ignored, end48))[2]
        _status = True
    else:
        _result = _raise_error301
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_308(_ctx, _text, _pos):
    # Begin Str
    value49 = 'and'
    end49 = (_pos + 3)
    if (_text[slice(_pos, end49, None)] == value49):
        _result = value49
        _pos = (yield (3, _ctx._try__ignored, end49))[2]
        _status = True
    else:
        _result = _raise_error308
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_306(_ctx, _text, _pos):
    # Begin Call
    # kw('and')
    arg29 = _wrap_string_literal('and', _parse_function_308)
    func27 = _ParseFunction(_ctx._try_kw, (arg29,), ())
    (_status, _result, _pos) = (yield (3, func27, _pos))
    # End Call
    yield (_status, _result, _pos)

def _parse_function_315(_ctx, _text, _pos):
    # Begin Str
    value50 = 'or'
    end50 = (_pos + 2)
    if (_text[slice(_pos, end50, None)] == value50):
        _result = value50
        _pos = (yield (3, _ctx._try__ignored, end50))[2]
        _status = True
    else:
        _result = _raise_error315
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_313(_ctx, _text, _pos):
    # Begin Call
    # kw('or')
    arg31 = _wrap_string_literal('or', _parse_function_315)
    func29 = _ParseFunction(_ctx._try_kw, (arg31,), ())
    (_status, _result, _pos) = (yield (3, func29, _pos))
    # End Call
    yield (_status, _result, _pos)

def _try_ValueExpression(_ctx, _text, _pos):
    # Rule 'ValueExpression'
    # Begin OperatorTable
    # Name | LiteralExpression with operators {
    #     mixfix: ((('(' >> Pad) >> ValueExpression) << Pad) << ')'
    #     postfix: ArgumentList, ElementAccess, FieldAccess
    #     prefix: '-'
    #     left: '*', '/', '%'
    #     left: '+', '-'
    #     infix: wrap('<<'), wrap('>>')
    #     infix: '<=', '<', '>=', '>'
    #     infix: '==', '!='
    #     left: '&'
    #     left: '^'
    #     left: wrap('|')
    #     prefix: kw('not')
    #     left: wrap(kw('and'))
    #     left: wrap(kw('or'))
    #     mixfix: If, Match
    # }
    _outer_checkpoint1 = _pos
    _operand_stack1 = []
    _operator_stack1 = []
    _operator_marker1 = 0
    while True:
        while True:
            _inner_checkpoint1 = _pos
            # Begin Longest
            has_result1 = False
            farthest_error_result1 = _raise_error228
            farthest_error_position1 = _raise_error228
            backtrack16 = farthest_position1 = farthest_error_position1 = _pos
            # Option 1:
            # Begin Apply
            # '-' |> `lambda x: (2, 0, x)`
            # Begin Str
            value29 = '-'
            end29 = (_pos + 1)
            if (_text[slice(_pos, end29, None)] == value29):
                _result = value29
                _pos = (yield (3, _ctx._try__ignored, end29))[2]
                _status = True
            else:
                _result = _raise_error230
                _status = False
            # End Str
            if _status:
                arg14 = _result
                _result = lambda x: (2, 0, x)
                _status = True
                _result = _result(arg14)
            # End Apply
            if _status:
                farthest_result1 = _result
                farthest_position1 = _pos
                has_result1 = True
            elif not has_result1 and ((farthest_error_position1 < _pos)):
                farthest_error_position1 = _pos
                farthest_error_result1 = _result
            _pos = backtrack16
            # Option 2:
            # Begin Apply
            # kw('not') |> `lambda x: (11, 0, x)`
            # Begin Call
            # kw('not')
            arg15 = _wrap_string_literal('not', _parse_function_235)
            func23 = _ParseFunction(_ctx._try_kw, (arg15,), ())
            (_status, _result, _pos) = (yield (3, func23, _pos))
            # End Call
            if _status:
                arg16 = _result
                _result = lambda x: (11, 0, x)
                _status = True
                _result = _result(arg16)
            # End Apply
            if _status:
                if not (has_result1):
                    farthest_result1 = _result
                    farthest_position1 = _pos
                    has_result1 = True
                elif (farthest_position1 < _pos):
                    farthest_result1 = _result
                    farthest_position1 = _pos
            elif not has_result1 and ((farthest_error_position1 < _pos)):
                farthest_error_position1 = _pos
                farthest_error_result1 = _result
            if has_result1:
                _result = farthest_result1
                _pos = farthest_position1
                _status = True
            else:
                _result = farthest_error_result1
                _pos = farthest_error_position1
            # End Longest
            if not (_status):
                _pos = _inner_checkpoint1
                break
            _operator_stack1.append(_result)
        _inner_checkpoint1 = _pos
        # Begin Longest
        has_result2 = False
        farthest_error_result2 = _raise_error237
        farthest_error_position2 = _raise_error237
        backtrack17 = farthest_position2 = farthest_error_position2 = _pos
        # Option 1:
        # Begin Choice
        farthest_err8 = _raise_error238
        backtrack18 = farthest_pos8 = _pos
        while True:
            # Option 1:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos8 < _pos):
                farthest_pos8 = _pos
                farthest_err8 = _result
            _pos = backtrack18
            # Option 2:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_LiteralExpression, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos8 < _pos):
                farthest_pos8 = _pos
                farthest_err8 = _result
            _pos = farthest_pos8
            _result = farthest_err8
            break
        # End Choice
        if _status:
            farthest_result2 = _result
            farthest_position2 = _pos
            has_result2 = True
        elif not has_result2 and ((farthest_error_position2 < _pos)):
            farthest_error_position2 = _pos
            farthest_error_result2 = _result
        _pos = backtrack17
        # Option 2:
        # Begin Discard
        # ((('(' >> Pad) >> ValueExpression) << Pad) << ')'
        while True:
            # Begin Discard
            # (('(' >> Pad) >> ValueExpression) << Pad
            while True:
                # Begin Discard
                # ('(' >> Pad) >> ValueExpression
                while True:
                    # Begin Discard
                    # '(' >> Pad
                    while True:
                        # Begin Str
                        value31 = '('
                        end31 = (_pos + 1)
                        if (_text[slice(_pos, end31, None)] == value31):
                            _result = value31
                            _pos = (yield (3, _ctx._try__ignored, end31))[2]
                            _status = True
                        else:
                            _result = _raise_error245
                            _status = False
                        # End Str
                        if not (_status):
                            break
                        # Begin Ref
                        (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                        # End Ref
                        break
                    # End Discard
                    if not (_status):
                        break
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
                    # End Ref
                    break
                # End Discard
                if not (_status):
                    break
                staging4 = _result
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                # End Ref
                if _status:
                    _result = staging4
                break
            # End Discard
            if not (_status):
                break
            staging5 = _result
            # Begin Str
            value32 = ')'
            end32 = (_pos + 1)
            if (_text[slice(_pos, end32, None)] == value32):
                _result = value32
                _pos = (yield (3, _ctx._try__ignored, end32))[2]
                _status = True
            else:
                _result = _raise_error249
                _status = False
            # End Str
            if _status:
                _result = staging5
            break
        # End Discard
        if _status:
            if not (has_result2):
                farthest_result2 = _result
                farthest_position2 = _pos
                has_result2 = True
            elif (farthest_position2 < _pos):
                farthest_result2 = _result
                farthest_position2 = _pos
        elif not has_result2 and ((farthest_error_position2 < _pos)):
            farthest_error_position2 = _pos
            farthest_error_result2 = _result
        _pos = backtrack17
        # Option 3:
        # Begin Choice
        farthest_err9 = _raise_error250
        backtrack19 = farthest_pos9 = _pos
        while True:
            # Option 1:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_If, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos9 < _pos):
                farthest_pos9 = _pos
                farthest_err9 = _result
            _pos = backtrack19
            # Option 2:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Match, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos9 < _pos):
                farthest_pos9 = _pos
                farthest_err9 = _result
            _pos = farthest_pos9
            _result = farthest_err9
            break
        # End Choice
        if _status:
            if not (has_result2):
                farthest_result2 = _result
                farthest_position2 = _pos
                has_result2 = True
            elif (farthest_position2 < _pos):
                farthest_result2 = _result
                farthest_position2 = _pos
        elif not has_result2 and ((farthest_error_position2 < _pos)):
            farthest_error_position2 = _pos
            farthest_error_result2 = _result
        if has_result2:
            _result = farthest_result2
            _pos = farthest_position2
            _status = True
        else:
            _result = farthest_error_result2
            _pos = farthest_error_position2
        # End Longest
        if not (_status):
            if _operand_stack1:
                _pos = _outer_checkpoint1
            break
        _operand_stack1.append(_result)
        while True:
            _inner_checkpoint1 = _pos
            # Begin Apply
            # (ArgumentList | ElementAccess | FieldAccess) |> `lambda x: (1, x)`
            # Begin Choice
            farthest_err10 = _raise_error254
            backtrack20 = farthest_pos10 = _pos
            while True:
                # Option 1:
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _ctx._try_ArgumentList, _pos))
                # End Ref
                if _status:
                    break
                if (farthest_pos10 < _pos):
                    farthest_pos10 = _pos
                    farthest_err10 = _result
                _pos = backtrack20
                # Option 2:
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _ctx._try_ElementAccess, _pos))
                # End Ref
                if _status:
                    break
                if (farthest_pos10 < _pos):
                    farthest_pos10 = _pos
                    farthest_err10 = _result
                _pos = backtrack20
                # Option 3:
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _ctx._try_FieldAccess, _pos))
                # End Ref
                if _status:
                    break
                if (farthest_pos10 < _pos):
                    farthest_pos10 = _pos
                    farthest_err10 = _result
                _pos = farthest_pos10
                _result = farthest_err10
                break
            # End Choice
            if _status:
                arg17 = _result
                _result = lambda x: (1, x)
                _status = True
                _result = _result(arg17)
            # End Apply
            if not (_status):
                _pos = _inner_checkpoint1
                break
            while _operator_stack1 and _operator_stack1[-1][0] < _result[0]:
                _, _is_infix, _operator = _operator_stack1.pop()
                _right = _operand_stack1.pop()
                if _is_infix:
                    _left = _operand_stack1.pop()
                    _operand_stack1.append(Infix(_left, _operator, _right))
                else:
                    _operand_stack1.append(Prefix(_operator, _right))
            _operand = _operand_stack1.pop()
            _operand_stack1.append(Postfix(_operand, _result[1]))
        _operator_marker1 = len(_operator_stack1)
        _outer_checkpoint1 = _pos
        # Begin Longest
        has_result3 = False
        farthest_error_result3 = _raise_error259
        farthest_error_position3 = _raise_error259
        backtrack21 = farthest_position3 = farthest_error_position3 = _pos
        # Option 1:
        # Begin Apply
        # ('*' | '/' | '%') |> `lambda x: (3, 1, x)`
        # Begin Choice
        farthest_err11 = _raise_error261
        farthest_pos11 = _pos
        while True:
            # Option 1:
            # Begin Str
            value33 = '*'
            end33 = (_pos + 1)
            if (_text[slice(_pos, end33, None)] == value33):
                _result = value33
                _pos = (yield (3, _ctx._try__ignored, end33))[2]
                _status = True
            else:
                _result = _raise_error262
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Str
            value34 = '/'
            end34 = (_pos + 1)
            if (_text[slice(_pos, end34, None)] == value34):
                _result = value34
                _pos = (yield (3, _ctx._try__ignored, end34))[2]
                _status = True
            else:
                _result = _raise_error263
                _status = False
            # End Str
            if _status:
                break
            # Option 3:
            # Begin Str
            value35 = '%'
            end35 = (_pos + 1)
            if (_text[slice(_pos, end35, None)] == value35):
                _result = value35
                _pos = (yield (3, _ctx._try__ignored, end35))[2]
                _status = True
            else:
                _result = _raise_error264
                _status = False
            # End Str
            if _status:
                break
            _pos = farthest_pos11
            _result = farthest_err11
            break
        # End Choice
        if _status:
            arg18 = _result
            _result = lambda x: (3, 1, x)
            _status = True
            _result = _result(arg18)
        # End Apply
        if _status:
            farthest_result3 = _result
            farthest_position3 = _pos
            has_result3 = True
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack21
        # Option 2:
        # Begin Apply
        # ('+' | '-') |> `lambda x: (4, 1, x)`
        # Begin Choice
        farthest_err12 = _raise_error267
        farthest_pos12 = _pos
        while True:
            # Option 1:
            # Begin Str
            value36 = '+'
            end36 = (_pos + 1)
            if (_text[slice(_pos, end36, None)] == value36):
                _result = value36
                _pos = (yield (3, _ctx._try__ignored, end36))[2]
                _status = True
            else:
                _result = _raise_error268
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Str
            value37 = '-'
            end37 = (_pos + 1)
            if (_text[slice(_pos, end37, None)] == value37):
                _result = value37
                _pos = (yield (3, _ctx._try__ignored, end37))[2]
                _status = True
            else:
                _result = _raise_error269
                _status = False
            # End Str
            if _status:
                break
            _pos = farthest_pos12
            _result = farthest_err12
            break
        # End Choice
        if _status:
            arg19 = _result
            _result = lambda x: (4, 1, x)
            _status = True
            _result = _result(arg19)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack21
        # Option 3:
        # Begin Apply
        # (wrap('<<') | wrap('>>')) |> `lambda x: (5, 3, x)`
        # Begin Choice
        farthest_err13 = _raise_error272
        backtrack22 = farthest_pos13 = _pos
        while True:
            # Option 1:
            # Begin Call
            # wrap('<<')
            arg20 = _wrap_string_literal('<<', _parse_function_275)
            func24 = _ParseFunction(_ctx._try_wrap, (arg20,), ())
            (_status, _result, _pos) = (yield (3, func24, _pos))
            # End Call
            if _status:
                break
            if (farthest_pos13 < _pos):
                farthest_pos13 = _pos
                farthest_err13 = _result
            _pos = backtrack22
            # Option 2:
            # Begin Call
            # wrap('>>')
            arg21 = _wrap_string_literal('>>', _parse_function_278)
            func25 = _ParseFunction(_ctx._try_wrap, (arg21,), ())
            (_status, _result, _pos) = (yield (3, func25, _pos))
            # End Call
            if _status:
                break
            if (farthest_pos13 < _pos):
                farthest_pos13 = _pos
                farthest_err13 = _result
            _pos = farthest_pos13
            _result = farthest_err13
            break
        # End Choice
        if _status:
            arg22 = _result
            _result = lambda x: (5, 3, x)
            _status = True
            _result = _result(arg22)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack21
        # Option 4:
        # Begin Apply
        # ('<=' | '<' | '>=' | '>') |> `lambda x: (6, 3, x)`
        # Begin Choice
        farthest_err14 = _raise_error281
        farthest_pos14 = _pos
        while True:
            # Option 1:
            # Begin Str
            value40 = '<='
            end40 = (_pos + 2)
            if (_text[slice(_pos, end40, None)] == value40):
                _result = value40
                _pos = (yield (3, _ctx._try__ignored, end40))[2]
                _status = True
            else:
                _result = _raise_error282
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Str
            value41 = '<'
            end41 = (_pos + 1)
            if (_text[slice(_pos, end41, None)] == value41):
                _result = value41
                _pos = (yield (3, _ctx._try__ignored, end41))[2]
                _status = True
            else:
                _result = _raise_error283
                _status = False
            # End Str
            if _status:
                break
            # Option 3:
            # Begin Str
            value42 = '>='
            end42 = (_pos + 2)
            if (_text[slice(_pos, end42, None)] == value42):
                _result = value42
                _pos = (yield (3, _ctx._try__ignored, end42))[2]
                _status = True
            else:
                _result = _raise_error284
                _status = False
            # End Str
            if _status:
                break
            # Option 4:
            # Begin Str
            value43 = '>'
            end43 = (_pos + 1)
            if (_text[slice(_pos, end43, None)] == value43):
                _result = value43
                _pos = (yield (3, _ctx._try__ignored, end43))[2]
                _status = True
            else:
                _result = _raise_error285
                _status = False
            # End Str
            if _status:
                break
            _pos = farthest_pos14
            _result = farthest_err14
            break
        # End Choice
        if _status:
            arg23 = _result
            _result = lambda x: (6, 3, x)
            _status = True
            _result = _result(arg23)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack21
        # Option 5:
        # Begin Apply
        # ('==' | '!=') |> `lambda x: (7, 3, x)`
        # Begin Choice
        farthest_err15 = _raise_error288
        farthest_pos15 = _pos
        while True:
            # Option 1:
            # Begin Str
            value44 = '=='
            end44 = (_pos + 2)
            if (_text[slice(_pos, end44, None)] == value44):
                _result = value44
                _pos = (yield (3, _ctx._try__ignored, end44))[2]
                _status = True
            else:
                _result = _raise_error289
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Str
            value45 = '!='
            end45 = (_pos + 2)
            if (_text[slice(_pos, end45, None)] == value45):
                _result = value45
                _pos = (yield (3, _ctx._try__ignored, end45))[2]
                _status = True
            else:
                _result = _raise_error290
                _status = False
            # End Str
            if _status:
                break
            _pos = farthest_pos15
            _result = farthest_err15
            break
        # End Choice
        if _status:
            arg24 = _result
            _result = lambda x: (7, 3, x)
            _status = True
            _result = _result(arg24)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack21
        # Option 6:
        # Begin Apply
        # '&' |> `lambda x: (8, 1, x)`
        # Begin Str
        value46 = '&'
        end46 = (_pos + 1)
        if (_text[slice(_pos, end46, None)] == value46):
            _result = value46
            _pos = (yield (3, _ctx._try__ignored, end46))[2]
            _status = True
        else:
            _result = _raise_error293
            _status = False
        # End Str
        if _status:
            arg25 = _result
            _result = lambda x: (8, 1, x)
            _status = True
            _result = _result(arg25)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack21
        # Option 7:
        # Begin Apply
        # '^' |> `lambda x: (9, 1, x)`
        # Begin Str
        value47 = '^'
        end47 = (_pos + 1)
        if (_text[slice(_pos, end47, None)] == value47):
            _result = value47
            _pos = (yield (3, _ctx._try__ignored, end47))[2]
            _status = True
        else:
            _result = _raise_error296
            _status = False
        # End Str
        if _status:
            arg26 = _result
            _result = lambda x: (9, 1, x)
            _status = True
            _result = _result(arg26)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack21
        # Option 8:
        # Begin Apply
        # wrap('|') |> `lambda x: (10, 1, x)`
        # Begin Call
        # wrap('|')
        arg27 = _wrap_string_literal('|', _parse_function_301)
        func26 = _ParseFunction(_ctx._try_wrap, (arg27,), ())
        (_status, _result, _pos) = (yield (3, func26, _pos))
        # End Call
        if _status:
            arg28 = _result
            _result = lambda x: (10, 1, x)
            _status = True
            _result = _result(arg28)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack21
        # Option 9:
        # Begin Apply
        # wrap(kw('and')) |> `lambda x: (12, 1, x)`
        # Begin Call
        # wrap(kw('and'))
        func28 = _ParseFunction(_ctx._try_wrap, (_parse_function_306,), ())
        (_status, _result, _pos) = (yield (3, func28, _pos))
        # End Call
        if _status:
            arg30 = _result
            _result = lambda x: (12, 1, x)
            _status = True
            _result = _result(arg30)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack21
        # Option 10:
        # Begin Apply
        # wrap(kw('or')) |> `lambda x: (13, 1, x)`
        # Begin Call
        # wrap(kw('or'))
        func30 = _ParseFunction(_ctx._try_wrap, (_parse_function_313,), ())
        (_status, _result, _pos) = (yield (3, func30, _pos))
        # End Call
        if _status:
            arg32 = _result
            _result = lambda x: (13, 1, x)
            _status = True
            _result = _result(arg32)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        if has_result3:
            _result = farthest_result3
            _pos = farthest_position3
            _status = True
        else:
            _result = farthest_error_result3
            _pos = farthest_error_position3
        # End Longest
        if not (_status):
            if _operand_stack1:
                _pos = _outer_checkpoint1
            break
        _prec = _result[0]
        while _operator_stack1:
            _top_prec, _top_assoc, _ = _operator_stack1[-1]
            if _top_prec < _prec or (_top_prec == _prec and _top_assoc == 1):
                _, _is_infix, _operator = _operator_stack1.pop()
                _right = _operand_stack1.pop()
                if _is_infix:
                    _left = _operand_stack1.pop()
                    _operand_stack1.append(Infix(_left, _operator, _right))
                else:
                    _operand_stack1.append(Prefix(_operator, _right))
            elif _top_prec == _prec and _top_assoc == 3:
                _pos = _outer_checkpoint1
                break
            else:
                break
        _operator_marker1 = len(_operator_stack1)
        _operator_stack1.append(_result)
    if _operand_stack1:
        _operator_stack1 = _operator_stack1[:_operator_marker1]
        while _operator_stack1:
            _, _is_infix, _operator = _operator_stack1.pop()
            _right = _operand_stack1.pop()
            if _is_infix:
                _left = _operand_stack1.pop()
                _operand_stack1.append(Infix(_left, _operator, _right))
            else:
                _operand_stack1.append(Prefix(_operator, _right))
        _result = _operand_stack1[0]
        _status = True
    # End OperatorTable
    yield (_status, _result, _pos)

def _parse_ValueExpression(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_ValueExpression, fullparse)

ValueExpression = ParsingRule('ValueExpression', _parse_ValueExpression, """
    ValueExpression = Name | LiteralExpression with operators {
        mixfix: ((('(' >> Pad) >> ValueExpression) << Pad) << ')'
        postfix: ArgumentList, ElementAccess, FieldAccess
        prefix: '-'
        left: '*', '/', '%'
        left: '+', '-'
        infix: wrap('<<'), wrap('>>')
        infix: '<=', '<', '>=', '>'
        infix: '==', '!='
        left: '&'
        left: '^'
        left: wrap('|')
        prefix: kw('not')
        left: wrap(kw('and'))
        left: wrap(kw('or'))
        mixfix: If, Match
    }
""")
def _raise_error227(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    Name | LiteralExpression with operators {\n    mixfix: ((('(' >> Pad) >> ValueExpression) << Pad) << ')'\n    postfix: ArgumentList, ElementAccess, FieldAccess\n    prefix: '-'\n    left: '*', '/', '%'\n    left: '+', '-'\n    infix: wrap('<<'), wrap('>>')\n    infix: '<=', '<', '>=', '>'\n    infix: '==', '!='\n    left: '&'\n    left: '^'\n    left: wrap('|')\n    prefix: kw('not')\n    left: wrap(kw('and'))\n    left: wrap(kw('or'))\n    mixfix: If, Match\n}\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error228(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    Longest('-' |> `lambda x: (2, 0, x)`, kw('not') |> `lambda x: (11, 0, x)`)\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error230(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '-'\n\n"
    "Expected to match the string '-'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error235(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    'not'\n\n"
    "Expected to match the string 'not'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error237(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    Longest(Name | LiteralExpression, ((('(' >> Pad) >> ValueExpression) << Pad) << ')', If | Match)\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error238(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    '    Name | LiteralExpression\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error245(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '('\n\n"
    "Expected to match the string '('"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error249(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    ')'\n\n"
    "Expected to match the string ')'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error250(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    '    If | Match\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error254(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    '    ArgumentList | ElementAccess | FieldAccess\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error259(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    Longest(('*' | '/' | '%') |> `lambda x: (3, 1, x)`, ('+' | '-') |> `lambda x: (4, 1, x)`, (wrap('<<') | wrap('>>')) |> `lambda x: (5, 3, x)`, ('<=' | '<' | '>=' | '>') |> `lambda x: (6, 3, x)`, ('==' | '!=') |> `lambda x: (7, 3, x)`, '&' |> `lambda x: (8, 1, x)`, '^' |> `lambda x: (9, 1, x)`, wrap('|') |> `lambda x: (10, 1, x)`, wrap(kw('and')) |> `lambda x: (12, 1, x)`, wrap(kw('or')) |> `lambda x: (13, 1, x)`)\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error261(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '*' | '/' | '%'\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error262(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '*'\n\n"
    "Expected to match the string '*'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error263(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '/'\n\n"
    "Expected to match the string '/'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error264(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '%'\n\n"
    "Expected to match the string '%'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error267(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '+' | '-'\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error268(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '+'\n\n"
    "Expected to match the string '+'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error269(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '-'\n\n"
    "Expected to match the string '-'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error272(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    wrap('<<') | wrap('>>')\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error275(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '<<'\n\n"
    "Expected to match the string '<<'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error278(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '>>'\n\n"
    "Expected to match the string '>>'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error281(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '<=' | '<' | '>=' | '>'\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error282(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '<='\n\n"
    "Expected to match the string '<='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error283(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '<'\n\n"
    "Expected to match the string '<'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error284(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '>='\n\n"
    "Expected to match the string '>='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error285(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '>'\n\n"
    "Expected to match the string '>'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error288(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '==' | '!='\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error289(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '=='\n\n"
    "Expected to match the string '=='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error290(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '!='\n\n"
    "Expected to match the string '!='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error293(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '&'\n\n"
    "Expected to match the string '&'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error296(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '^'\n\n"
    "Expected to match the string '^'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error301(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '|'\n\n"
    "Expected to match the string '|'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error308(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    'and'\n\n"
    "Expected to match the string 'and'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error315(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    'or'\n\n"
    "Expected to match the string 'or'"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_LiteralExpression(_ctx, _text, _pos):
    # Rule 'LiteralExpression'
    # Begin Choice
    farthest_err16 = _raise_error318
    backtrack23 = farthest_pos16 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_EmptyMapLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos16 < _pos):
            farthest_pos16 = _pos
            farthest_err16 = _result
        _pos = backtrack23
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ListLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos16 < _pos):
            farthest_pos16 = _pos
            farthest_err16 = _result
        _pos = backtrack23
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_MapLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos16 < _pos):
            farthest_pos16 = _pos
            farthest_err16 = _result
        _pos = backtrack23
        # Option 4:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_NumberLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos16 < _pos):
            farthest_pos16 = _pos
            farthest_err16 = _result
        _pos = backtrack23
        # Option 5:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_SetLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos16 < _pos):
            farthest_pos16 = _pos
            farthest_err16 = _result
        _pos = backtrack23
        # Option 6:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_StringLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos16 < _pos):
            farthest_pos16 = _pos
            farthest_err16 = _result
        _pos = backtrack23
        # Option 7:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_TupleLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos16 < _pos):
            farthest_pos16 = _pos
            farthest_err16 = _result
        _pos = farthest_pos16
        _result = farthest_err16
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_LiteralExpression(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_LiteralExpression, fullparse)

LiteralExpression = ParsingRule('LiteralExpression', _parse_LiteralExpression, """
    LiteralExpression = EmptyMapLiteral | ListLiteral | MapLiteral | NumberLiteral | SetLiteral | StringLiteral | TupleLiteral
""")
def _raise_error318(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'LiteralExpression' rule, at the expression:\n"
    '    EmptyMapLiteral | ListLiteral | MapLiteral | NumberLiteral | SetLiteral | StringLiteral | TupleLiteral\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class EmptyMapLiteral(ParsedObject):
    """
    class EmptyMapLiteral {
        pass ((('{' >> Pad) >> ':') << Pad) << '}'
    }
    """
    _fields = ()

    def __init__(self):
        ParsedObject.__init__(self)

    def __repr__(self):
        return f'EmptyMapLiteral()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_EmptyMapLiteral, fullparse)


def _try_EmptyMapLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos12 = _pos
    while True:
        # Begin Discard
        # ((('{' >> Pad) >> ':') << Pad) << '}'
        while True:
            # Begin Discard
            # (('{' >> Pad) >> ':') << Pad
            while True:
                # Begin Discard
                # ('{' >> Pad) >> ':'
                while True:
                    # Begin Discard
                    # '{' >> Pad
                    while True:
                        # Begin Str
                        value51 = '{'
                        end51 = (_pos + 1)
                        if (_text[slice(_pos, end51, None)] == value51):
                            _result = value51
                            _pos = (yield (3, _ctx._try__ignored, end51))[2]
                            _status = True
                        else:
                            _result = _raise_error333
                            _status = False
                        # End Str
                        if not (_status):
                            break
                        # Begin Ref
                        (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                        # End Ref
                        break
                    # End Discard
                    if not (_status):
                        break
                    # Begin Str
                    value52 = ':'
                    end52 = (_pos + 1)
                    if (_text[slice(_pos, end52, None)] == value52):
                        _result = value52
                        _pos = (yield (3, _ctx._try__ignored, end52))[2]
                        _status = True
                    else:
                        _result = _raise_error335
                        _status = False
                    # End Str
                    break
                # End Discard
                if not (_status):
                    break
                staging6 = _result
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                # End Ref
                if _status:
                    _result = staging6
                break
            # End Discard
            if not (_status):
                break
            staging7 = _result
            # Begin Str
            value53 = '}'
            end53 = (_pos + 1)
            if (_text[slice(_pos, end53, None)] == value53):
                _result = value53
                _pos = (yield (3, _ctx._try__ignored, end53))[2]
                _status = True
            else:
                _result = _raise_error337
                _status = False
            # End Str
            if _status:
                _result = staging7
            break
        # End Discard
        if not (_status):
            break
        item2 = _result
        _result = EmptyMapLiteral()
        _result._metadata.position_info = (start_pos12, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error333(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'EmptyMapLiteral' rule, at the expression:\n"
    "    '{'\n\n"
    "Expected to match the string '{'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error335(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'EmptyMapLiteral' rule, at the expression:\n"
    "    ':'\n\n"
    "Expected to match the string ':'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error337(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'EmptyMapLiteral' rule, at the expression:\n"
    "    '}'\n\n"
    "Expected to match the string '}'"
    )
    raise ParseError((title + details), _pos, line, col)

class ListLiteral(ParsedObject):
    """
    class ListLiteral {
        elements: SquareList(ValueExpression)
    }
    """
    _fields = ('elements',)

    def __init__(self, elements):
        ParsedObject.__init__(self)
        self.elements = elements

    def __repr__(self):
        return f'ListLiteral(elements={self.elements!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_ListLiteral, fullparse)


def _try_ListLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos13 = _pos
    while True:
        # Begin Call
        # SquareList(ValueExpression)
        func31 = _ParseFunction(_ctx._try_SquareList, (_try_ValueExpression,), ())
        (_status, _result, _pos) = (yield (3, func31, _pos))
        # End Call
        if not (_status):
            break
        elements = _result
        _result = ListLiteral(elements)
        _result._metadata.position_info = (start_pos13, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

class MapLiteral(ParsedObject):
    """
    class MapLiteral {
        pairs: CurlyList(Pair)
    }
    """
    _fields = ('pairs',)

    def __init__(self, pairs):
        ParsedObject.__init__(self)
        self.pairs = pairs

    def __repr__(self):
        return f'MapLiteral(pairs={self.pairs!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_MapLiteral, fullparse)


def _try_MapLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos14 = _pos
    while True:
        # Begin Call
        # CurlyList(Pair)
        func32 = _ParseFunction(_ctx._try_CurlyList, (_try_Pair,), ())
        (_status, _result, _pos) = (yield (3, func32, _pos))
        # End Call
        if not (_status):
            break
        pairs = _result
        _result = MapLiteral(pairs)
        _result._metadata.position_info = (start_pos14, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

class Pair(ParsedObject):
    """
    class Pair {
        key: ValueExpression
        value: ':' >> ValueExpression
    }
    """
    _fields = ('key', 'value')

    def __init__(self, key, value):
        ParsedObject.__init__(self)
        self.key = key
        self.value = value

    def __repr__(self):
        return f'Pair(key={self.key!r}, value={self.value!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Pair, fullparse)


def _try_Pair(_ctx, _text, _pos):
    # Begin Seq
    start_pos15 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        key = _result
        # Begin Discard
        # ':' >> ValueExpression
        while True:
            # Begin Str
            value54 = ':'
            end54 = (_pos + 1)
            if (_text[slice(_pos, end54, None)] == value54):
                _result = value54
                _pos = (yield (3, _ctx._try__ignored, end54))[2]
                _status = True
            else:
                _result = _raise_error356
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            break
        value = _result
        _result = Pair(key, value)
        _result._metadata.position_info = (start_pos15, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error356(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Pair' rule, at the expression:\n"
    "    ':'\n\n"
    "Expected to match the string ':'"
    )
    raise ParseError((title + details), _pos, line, col)

class NumberLiteral(ParsedObject):
    """
    class NumberLiteral {
        value: /\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+/
    }
    """
    _fields = ('value',)

    def __init__(self, value):
        ParsedObject.__init__(self)
        self.value = value

    def __repr__(self):
        return f'NumberLiteral(value={self.value!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_NumberLiteral, fullparse)


def _try_NumberLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos16 = _pos
    while True:
        # Begin Regex
        # /\\d+(\\.\\d*)?|\\.\\d+/
        match7 = matcher7(_text, _pos)
        if match7:
            _result = match7.group(0)
            _pos = (yield (3, _ctx._try__ignored, match7.end()))[2]
            _status = True
        else:
            _result = _raise_error361
            _status = False
        # End Regex
        if not (_status):
            break
        value = _result
        _result = NumberLiteral(value)
        _result._metadata.position_info = (start_pos16, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error361(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberLiteral' rule, at the expression:\n"
    '    /\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+/\n\n'
    'Expected to match the regular expression /\\d+(\\.\\d*)?|\\.\\d+/'
    )
    raise ParseError((title + details), _pos, line, col)

class SetLiteral(ParsedObject):
    """
    class SetLiteral {
        elements: CurlyList(ValueExpression)
    }
    """
    _fields = ('elements',)

    def __init__(self, elements):
        ParsedObject.__init__(self)
        self.elements = elements

    def __repr__(self):
        return f'SetLiteral(elements={self.elements!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_SetLiteral, fullparse)


def _try_SetLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos17 = _pos
    while True:
        # Begin Call
        # CurlyList(ValueExpression)
        func33 = _ParseFunction(_ctx._try_CurlyList, (_try_ValueExpression,), ())
        (_status, _result, _pos) = (yield (3, func33, _pos))
        # End Call
        if not (_status):
            break
        elements = _result
        _result = SetLiteral(elements)
        _result._metadata.position_info = (start_pos17, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

class StringLiteral(ParsedObject):
    """
    class StringLiteral {
        contents: /"(?:[^\\\\\\\\"]|\\\\\\\\.)*"/ |> `literal_eval`
    }
    """
    _fields = ('contents',)

    def __init__(self, contents):
        ParsedObject.__init__(self)
        self.contents = contents

    def __repr__(self):
        return f'StringLiteral(contents={self.contents!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_StringLiteral, fullparse)


def _try_StringLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos18 = _pos
    while True:
        # Begin Apply
        # /"(?:[^\\\\"]|\\\\.)*"/ |> `literal_eval`
        # Begin Regex
        # /"(?:[^\\\\"]|\\\\.)*"/
        match8 = matcher8(_text, _pos)
        if match8:
            _result = match8.group(0)
            _pos = (yield (3, _ctx._try__ignored, match8.end()))[2]
            _status = True
        else:
            _result = _raise_error372
            _status = False
        # End Regex
        if _status:
            arg33 = _result
            _result = literal_eval
            _status = True
            _result = _result(arg33)
        # End Apply
        if not (_status):
            break
        contents = _result
        _result = StringLiteral(contents)
        _result._metadata.position_info = (start_pos18, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error372(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'StringLiteral' rule, at the expression:\n"
    '    /"(?:[^\\\\\\\\"]|\\\\\\\\.)*"/\n\n'
    'Expected to match the regular expression /"(?:[^\\\\"]|\\\\.)*"/'
    )
    raise ParseError((title + details), _pos, line, col)

class TupleLiteral(ParsedObject):
    """
    class TupleLiteral {
        pass '('
        elements: Sep(ValueExpression, Comma, allow_trailer=true, require_separator=True)
        pass ')'
    }
    """
    _fields = ('elements',)

    def __init__(self, elements):
        ParsedObject.__init__(self)
        self.elements = elements

    def __repr__(self):
        return f'TupleLiteral(elements={self.elements!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_TupleLiteral, fullparse)


def _try_TupleLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos19 = _pos
    while True:
        # Begin Str
        value55 = '('
        end55 = (_pos + 1)
        if (_text[slice(_pos, end55, None)] == value55):
            _result = value55
            _pos = (yield (3, _ctx._try__ignored, end55))[2]
            _status = True
        else:
            _result = _raise_error377
            _status = False
        # End Str
        if not (_status):
            break
        item3 = _result
        # Begin Sep
        # Sep(ValueExpression, Comma, allow_trailer=true, require_separator=True)
        staging8 = []
        checkpoint2 = _pos
        saw_separator1 = False
        while True:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            if not (_status):
                break
            staging8.append(_result)
            checkpoint2 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Comma, _pos))
            # End Ref
            if not (_status):
                break
            checkpoint2 = _pos
            saw_separator1 = True
        if not staging8 or saw_separator1:
            _result = staging8
            _pos = checkpoint2
            _status = True
        # End Sep
        if not (_status):
            break
        elements = _result
        # Begin Str
        value56 = ')'
        end56 = (_pos + 1)
        if (_text[slice(_pos, end56, None)] == value56):
            _result = value56
            _pos = (yield (3, _ctx._try__ignored, end56))[2]
            _status = True
        else:
            _result = _raise_error385
            _status = False
        # End Str
        if not (_status):
            break
        item4 = _result
        _result = TupleLiteral(elements)
        _result._metadata.position_info = (start_pos19, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error377(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'TupleLiteral' rule, at the expression:\n"
    "    '('\n\n"
    "Expected to match the string '('"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error385(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'TupleLiteral' rule, at the expression:\n"
    "    ')'\n\n"
    "Expected to match the string ')'"
    )
    raise ParseError((title + details), _pos, line, col)

class ArgumentList(ParsedObject):
    """
    class ArgumentList {
        arguments: ParenthesesList(ValueExpression)
    }
    """
    _fields = ('arguments',)

    def __init__(self, arguments):
        ParsedObject.__init__(self)
        self.arguments = arguments

    def __repr__(self):
        return f'ArgumentList(arguments={self.arguments!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_ArgumentList, fullparse)


def _try_ArgumentList(_ctx, _text, _pos):
    # Begin Seq
    start_pos20 = _pos
    while True:
        # Begin Call
        # ParenthesesList(ValueExpression)
        func34 = _ParseFunction(_ctx._try_ParenthesesList, (_try_ValueExpression,), ())
        (_status, _result, _pos) = (yield (3, func34, _pos))
        # End Call
        if not (_status):
            break
        arguments = _result
        _result = ArgumentList(arguments)
        _result._metadata.position_info = (start_pos20, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

class ElementAccess(ParsedObject):
    """
    class ElementAccess {
        index: ((('[' >> Pad) >> Expr) << Pad) << ']'
    }
    """
    _fields = ('index',)

    def __init__(self, index):
        ParsedObject.__init__(self)
        self.index = index

    def __repr__(self):
        return f'ElementAccess(index={self.index!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_ElementAccess, fullparse)


def _try_ElementAccess(_ctx, _text, _pos):
    # Begin Seq
    start_pos21 = _pos
    while True:
        # Begin Discard
        # ((('[' >> Pad) >> Expr) << Pad) << ']'
        while True:
            # Begin Discard
            # (('[' >> Pad) >> Expr) << Pad
            while True:
                # Begin Discard
                # ('[' >> Pad) >> Expr
                while True:
                    # Begin Discard
                    # '[' >> Pad
                    while True:
                        # Begin Str
                        value57 = '['
                        end57 = (_pos + 1)
                        if (_text[slice(_pos, end57, None)] == value57):
                            _result = value57
                            _pos = (yield (3, _ctx._try__ignored, end57))[2]
                            _status = True
                        else:
                            _result = _raise_error399
                            _status = False
                        # End Str
                        if not (_status):
                            break
                        # Begin Ref
                        (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                        # End Ref
                        break
                    # End Discard
                    if not (_status):
                        break
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _ctx.Expr, _pos))
                    # End Ref
                    break
                # End Discard
                if not (_status):
                    break
                staging9 = _result
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                # End Ref
                if _status:
                    _result = staging9
                break
            # End Discard
            if not (_status):
                break
            staging10 = _result
            # Begin Str
            value58 = ']'
            end58 = (_pos + 1)
            if (_text[slice(_pos, end58, None)] == value58):
                _result = value58
                _pos = (yield (3, _ctx._try__ignored, end58))[2]
                _status = True
            else:
                _result = _raise_error403
                _status = False
            # End Str
            if _status:
                _result = staging10
            break
        # End Discard
        if not (_status):
            break
        index = _result
        _result = ElementAccess(index)
        _result._metadata.position_info = (start_pos21, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error399(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ElementAccess' rule, at the expression:\n"
    "    '['\n\n"
    "Expected to match the string '['"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error403(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ElementAccess' rule, at the expression:\n"
    "    ']'\n\n"
    "Expected to match the string ']'"
    )
    raise ParseError((title + details), _pos, line, col)

class FieldAccess(ParsedObject):
    """
    class FieldAccess {
        field: '.' >> Word
    }
    """
    _fields = ('field',)

    def __init__(self, field):
        ParsedObject.__init__(self)
        self.field = field

    def __repr__(self):
        return f'FieldAccess(field={self.field!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_FieldAccess, fullparse)


def _try_FieldAccess(_ctx, _text, _pos):
    # Begin Seq
    start_pos22 = _pos
    while True:
        # Begin Discard
        # '.' >> Word
        while True:
            # Begin Str
            value59 = '.'
            end59 = (_pos + 1)
            if (_text[slice(_pos, end59, None)] == value59):
                _result = value59
                _pos = (yield (3, _ctx._try__ignored, end59))[2]
                _status = True
            else:
                _result = _raise_error408
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Word, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            break
        field = _result
        _result = FieldAccess(field)
        _result._metadata.position_info = (start_pos22, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error408(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'FieldAccess' rule, at the expression:\n"
    "    '.'\n\n"
    "Expected to match the string '.'"
    )
    raise ParseError((title + details), _pos, line, col)

class If(ParsedObject):
    """
    class If {
        condition: kw('if') >> ValueExpression
        then_branch: Block(Statement)
        else_branch: Opt(kw('else') >> Block(Statement))
    }
    """
    _fields = ('condition', 'then_branch', 'else_branch')

    def __init__(self, condition, then_branch, else_branch):
        ParsedObject.__init__(self)
        self.condition = condition
        self.then_branch = then_branch
        self.else_branch = else_branch

    def __repr__(self):
        return f'If(condition={self.condition!r}, then_branch={self.then_branch!r}, else_branch={self.else_branch!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_If, fullparse)


def _parse_function_416(_ctx, _text, _pos):
    # Begin Str
    value60 = 'if'
    end60 = (_pos + 2)
    if (_text[slice(_pos, end60, None)] == value60):
        _result = value60
        _pos = (yield (3, _ctx._try__ignored, end60))[2]
        _status = True
    else:
        _result = _raise_error416
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_427(_ctx, _text, _pos):
    # Begin Str
    value61 = 'else'
    end61 = (_pos + 4)
    if (_text[slice(_pos, end61, None)] == value61):
        _result = value61
        _pos = (yield (3, _ctx._try__ignored, end61))[2]
        _status = True
    else:
        _result = _raise_error427
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_If(_ctx, _text, _pos):
    # Begin Seq
    start_pos23 = _pos
    while True:
        # Begin Discard
        # kw('if') >> ValueExpression
        while True:
            # Begin Call
            # kw('if')
            arg34 = _wrap_string_literal('if', _parse_function_416)
            func35 = _ParseFunction(_ctx._try_kw, (arg34,), ())
            (_status, _result, _pos) = (yield (3, func35, _pos))
            # End Call
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            break
        condition = _result
        # Begin Call
        # Block(Statement)
        func36 = _ParseFunction(_ctx._try_Block, (_try_Statement,), ())
        (_status, _result, _pos) = (yield (3, func36, _pos))
        # End Call
        if not (_status):
            break
        then_branch = _result
        # Begin Opt
        # Opt(kw('else') >> Block(Statement))
        backtrack24 = _pos
        # Begin Discard
        # kw('else') >> Block(Statement)
        while True:
            # Begin Call
            # kw('else')
            arg35 = _wrap_string_literal('else', _parse_function_427)
            func37 = _ParseFunction(_ctx._try_kw, (arg35,), ())
            (_status, _result, _pos) = (yield (3, func37, _pos))
            # End Call
            if not (_status):
                break
            # Begin Call
            # Block(Statement)
            func38 = _ParseFunction(_ctx._try_Block, (_try_Statement,), ())
            (_status, _result, _pos) = (yield (3, func38, _pos))
            # End Call
            break
        # End Discard
        if not (_status):
            _pos = backtrack24
            _result = None
            _status = True
        # End Opt
        else_branch = _result
        _result = If(condition, then_branch, else_branch)
        _result._metadata.position_info = (start_pos23, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error416(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'If' rule, at the expression:\n"
    "    'if'\n\n"
    "Expected to match the string 'if'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error427(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'If' rule, at the expression:\n"
    "    'else'\n\n"
    "Expected to match the string 'else'"
    )
    raise ParseError((title + details), _pos, line, col)

class Match(ParsedObject):
    """
    class Match {
        value: kw('match') >> ValueExpression
        cases: Block(MatchCase)
    }
    """
    _fields = ('value', 'cases')

    def __init__(self, value, cases):
        ParsedObject.__init__(self)
        self.value = value
        self.cases = cases

    def __repr__(self):
        return f'Match(value={self.value!r}, cases={self.cases!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Match, fullparse)


def _parse_function_437(_ctx, _text, _pos):
    # Begin Str
    value62 = 'match'
    end62 = (_pos + 5)
    if (_text[slice(_pos, end62, None)] == value62):
        _result = value62
        _pos = (yield (3, _ctx._try__ignored, end62))[2]
        _status = True
    else:
        _result = _raise_error437
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Match(_ctx, _text, _pos):
    # Begin Seq
    start_pos24 = _pos
    while True:
        # Begin Discard
        # kw('match') >> ValueExpression
        while True:
            # Begin Call
            # kw('match')
            arg36 = _wrap_string_literal('match', _parse_function_437)
            func39 = _ParseFunction(_ctx._try_kw, (arg36,), ())
            (_status, _result, _pos) = (yield (3, func39, _pos))
            # End Call
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            break
        value = _result
        # Begin Call
        # Block(MatchCase)
        func40 = _ParseFunction(_ctx._try_Block, (_try_MatchCase,), ())
        (_status, _result, _pos) = (yield (3, func40, _pos))
        # End Call
        if not (_status):
            break
        cases = _result
        _result = Match(value, cases)
        _result._metadata.position_info = (start_pos24, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error437(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Match' rule, at the expression:\n"
    "    'match'\n\n"
    "Expected to match the string 'match'"
    )
    raise ParseError((title + details), _pos, line, col)

class MatchCase(ParsedObject):
    """
    class MatchCase {
        pattern: kw('case') >> (ValueExpression | '*')
        guard: Opt(kw('if') >> ValueExpression)
        body: Block(Statement)
    }
    """
    _fields = ('pattern', 'guard', 'body')

    def __init__(self, pattern, guard, body):
        ParsedObject.__init__(self)
        self.pattern = pattern
        self.guard = guard
        self.body = body

    def __repr__(self):
        return f'MatchCase(pattern={self.pattern!r}, guard={self.guard!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_MatchCase, fullparse)


def _parse_function_449(_ctx, _text, _pos):
    # Begin Str
    value63 = 'case'
    end63 = (_pos + 4)
    if (_text[slice(_pos, end63, None)] == value63):
        _result = value63
        _pos = (yield (3, _ctx._try__ignored, end63))[2]
        _status = True
    else:
        _result = _raise_error449
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_458(_ctx, _text, _pos):
    # Begin Str
    value65 = 'if'
    end65 = (_pos + 2)
    if (_text[slice(_pos, end65, None)] == value65):
        _result = value65
        _pos = (yield (3, _ctx._try__ignored, end65))[2]
        _status = True
    else:
        _result = _raise_error458
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_MatchCase(_ctx, _text, _pos):
    # Begin Seq
    start_pos25 = _pos
    while True:
        # Begin Discard
        # kw('case') >> (ValueExpression | '*')
        while True:
            # Begin Call
            # kw('case')
            arg37 = _wrap_string_literal('case', _parse_function_449)
            func41 = _ParseFunction(_ctx._try_kw, (arg37,), ())
            (_status, _result, _pos) = (yield (3, func41, _pos))
            # End Call
            if not (_status):
                break
            # Begin Choice
            farthest_err17 = _raise_error450
            backtrack25 = farthest_pos17 = _pos
            while True:
                # Option 1:
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
                # End Ref
                if _status:
                    break
                if (farthest_pos17 < _pos):
                    farthest_pos17 = _pos
                    farthest_err17 = _result
                _pos = backtrack25
                # Option 2:
                # Begin Str
                value64 = '*'
                end64 = (_pos + 1)
                if (_text[slice(_pos, end64, None)] == value64):
                    _result = value64
                    _pos = (yield (3, _ctx._try__ignored, end64))[2]
                    _status = True
                else:
                    _result = _raise_error452
                    _status = False
                # End Str
                if _status:
                    break
                _pos = farthest_pos17
                _result = farthest_err17
                break
            # End Choice
            break
        # End Discard
        if not (_status):
            break
        pattern = _result
        # Begin Opt
        # Opt(kw('if') >> ValueExpression)
        backtrack26 = _pos
        # Begin Discard
        # kw('if') >> ValueExpression
        while True:
            # Begin Call
            # kw('if')
            arg38 = _wrap_string_literal('if', _parse_function_458)
            func42 = _ParseFunction(_ctx._try_kw, (arg38,), ())
            (_status, _result, _pos) = (yield (3, func42, _pos))
            # End Call
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack26
            _result = None
            _status = True
        # End Opt
        guard = _result
        # Begin Call
        # Block(Statement)
        func43 = _ParseFunction(_ctx._try_Block, (_try_Statement,), ())
        (_status, _result, _pos) = (yield (3, func43, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = MatchCase(pattern, guard, body)
        _result._metadata.position_info = (start_pos25, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error449(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MatchCase' rule, at the expression:\n"
    "    'case'\n\n"
    "Expected to match the string 'case'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error450(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MatchCase' rule, at the expression:\n"
    "    ValueExpression | '*'\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error452(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MatchCase' rule, at the expression:\n"
    "    '*'\n\n"
    "Expected to match the string '*'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error458(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MatchCase' rule, at the expression:\n"
    "    'if'\n\n"
    "Expected to match the string 'if'"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Block(_ctx, _text, _pos, T):
    # Rule 'Block'
    # Begin Discard
    # ((((Pad >> '{') >> Pad) >> (T /? LineSep)) << Pad) << '}'
    while True:
        # Begin Discard
        # (((Pad >> '{') >> Pad) >> (T /? LineSep)) << Pad
        while True:
            # Begin Discard
            # ((Pad >> '{') >> Pad) >> (T /? LineSep)
            while True:
                # Begin Discard
                # (Pad >> '{') >> Pad
                while True:
                    # Begin Discard
                    # Pad >> '{'
                    while True:
                        # Begin Ref
                        (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                        # End Ref
                        if not (_status):
                            break
                        # Begin Str
                        value66 = '{'
                        end66 = (_pos + 1)
                        if (_text[slice(_pos, end66, None)] == value66):
                            _result = value66
                            _pos = (yield (3, _ctx._try__ignored, end66))[2]
                            _status = True
                        else:
                            _result = _raise_error471
                            _status = False
                        # End Str
                        break
                    # End Discard
                    if not (_status):
                        break
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                    # End Ref
                    break
                # End Discard
                if not (_status):
                    break
                # Begin Sep
                # T /? LineSep
                staging11 = []
                checkpoint3 = _pos
                while True:
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, T, _pos))
                    # End Ref
                    if not (_status):
                        break
                    staging11.append(_result)
                    checkpoint3 = _pos
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _ctx._try_LineSep, _pos))
                    # End Ref
                    if not (_status):
                        break
                    checkpoint3 = _pos
                _result = staging11
                _pos = checkpoint3
                _status = True
                # End Sep
                break
            # End Discard
            if not (_status):
                break
            staging12 = _result
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
            # End Ref
            if _status:
                _result = staging12
            break
        # End Discard
        if not (_status):
            break
        staging13 = _result
        # Begin Str
        value67 = '}'
        end67 = (_pos + 1)
        if (_text[slice(_pos, end67, None)] == value67):
            _result = value67
            _pos = (yield (3, _ctx._try__ignored, end67))[2]
            _status = True
        else:
            _result = _raise_error477
            _status = False
        # End Str
        if _status:
            _result = staging13
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_Block(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Block, fullparse)

Block = ParsingRule('Block', _parse_Block, """
    Block(T) = ((((Pad >> '{') >> Pad) >> (T /? LineSep)) << Pad) << '}'
""")
def _raise_error471(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Block' rule, at the expression:\n"
    "    '{'\n\n"
    "Expected to match the string '{'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error477(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Block' rule, at the expression:\n"
    "    '}'\n\n"
    "Expected to match the string '}'"
    )
    raise ParseError((title + details), _pos, line, col)

def _parse_function_481(_ctx, _text, _pos):
    # Begin Str
    value68 = ','
    end68 = (_pos + 1)
    if (_text[slice(_pos, end68, None)] == value68):
        _result = value68
        _pos = (yield (3, _ctx._try__ignored, end68))[2]
        _status = True
    else:
        _result = _raise_error481
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Comma(_ctx, _text, _pos):
    # Rule 'Comma'
    # Begin Call
    # wrap(',')
    arg39 = _wrap_string_literal(',', _parse_function_481)
    func44 = _ParseFunction(_ctx._try_wrap, (arg39,), ())
    (_status, _result, _pos) = (yield (3, func44, _pos))
    # End Call
    yield (_status, _result, _pos)

def _parse_Comma(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Comma, fullparse)

Comma = ParsingRule('Comma', _parse_Comma, """
    Comma = wrap(',')
""")
def _raise_error481(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Comma' rule, at the expression:\n"
    "    ','\n\n"
    "Expected to match the string ','"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_LineSep(_ctx, _text, _pos):
    # Rule 'LineSep'
    # Begin Regex
    # /[\\n\\r]+/
    match9 = matcher9(_text, _pos)
    if match9:
        _result = match9.group(0)
        _pos = (yield (3, _ctx._try__ignored, match9.end()))[2]
        _status = True
    else:
        _result = _raise_error483
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_LineSep(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_LineSep, fullparse)

LineSep = ParsingRule('LineSep', _parse_LineSep, """
    LineSep = /[\\n\\r]+/
""")
def _raise_error483(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'LineSep' rule, at the expression:\n"
    '    /[\\\\n\\\\r]+/\n\n'
    'Expected to match the regular expression /[\\n\\r]+/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Lines(_ctx, _text, _pos, T):
    # Rule 'Lines'
    # Begin Sep
    # T /? LineSep
    staging14 = []
    checkpoint4 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, T, _pos))
        # End Ref
        if not (_status):
            break
        staging14.append(_result)
        checkpoint4 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_LineSep, _pos))
        # End Ref
        if not (_status):
            break
        checkpoint4 = _pos
    _result = staging14
    _pos = checkpoint4
    _status = True
    # End Sep
    yield (_status, _result, _pos)

def _parse_Lines(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Lines, fullparse)

Lines = ParsingRule('Lines', _parse_Lines, """
    Lines(T) = T /? LineSep
""")
class Parameter(ParsedObject):
    """
    class Parameter {
        name: Name
        type: Opt(':' >> TypeExpression)
        default: Opt('=' >> ValueExpression)
    }
    """
    _fields = ('name', 'type', 'default')

    def __init__(self, name, type, default):
        ParsedObject.__init__(self)
        self.name = name
        self.type = type
        self.default = default

    def __repr__(self):
        return f'Parameter(name={self.name!r}, type={self.type!r}, default={self.default!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Parameter, fullparse)


def _try_Parameter(_ctx, _text, _pos):
    # Begin Seq
    start_pos26 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
        # End Ref
        if not (_status):
            break
        name = _result
        # Begin Opt
        # Opt(':' >> TypeExpression)
        backtrack27 = _pos
        # Begin Discard
        # ':' >> TypeExpression
        while True:
            # Begin Str
            value69 = ':'
            end69 = (_pos + 1)
            if (_text[slice(_pos, end69, None)] == value69):
                _result = value69
                _pos = (yield (3, _ctx._try__ignored, end69))[2]
                _status = True
            else:
                _result = _raise_error495
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_TypeExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack27
            _result = None
            _status = True
        # End Opt
        type = _result
        # Begin Opt
        # Opt('=' >> ValueExpression)
        backtrack28 = _pos
        # Begin Discard
        # '=' >> ValueExpression
        while True:
            # Begin Str
            value70 = '='
            end70 = (_pos + 1)
            if (_text[slice(_pos, end70, None)] == value70):
                _result = value70
                _pos = (yield (3, _ctx._try__ignored, end70))[2]
                _status = True
            else:
                _result = _raise_error500
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack28
            _result = None
            _status = True
        # End Opt
        default = _result
        _result = Parameter(name, type, default)
        _result._metadata.position_info = (start_pos26, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error495(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Parameter' rule, at the expression:\n"
    "    ':'\n\n"
    "Expected to match the string ':'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error500(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Parameter' rule, at the expression:\n"
    "    '='\n\n"
    "Expected to match the string '='"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_SurroundedList(_ctx, _text, _pos, L, T, R):
    # Rule 'SurroundedList'
    # Begin Discard
    # (((L >> Pad) >> (T /? Comma)) << Pad) << R
    while True:
        # Begin Discard
        # ((L >> Pad) >> (T /? Comma)) << Pad
        while True:
            # Begin Discard
            # (L >> Pad) >> (T /? Comma)
            while True:
                # Begin Discard
                # L >> Pad
                while True:
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, L, _pos))
                    # End Ref
                    if not (_status):
                        break
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                    # End Ref
                    break
                # End Discard
                if not (_status):
                    break
                # Begin Sep
                # T /? Comma
                staging15 = []
                checkpoint5 = _pos
                while True:
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, T, _pos))
                    # End Ref
                    if not (_status):
                        break
                    staging15.append(_result)
                    checkpoint5 = _pos
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _ctx._try_Comma, _pos))
                    # End Ref
                    if not (_status):
                        break
                    checkpoint5 = _pos
                _result = staging15
                _pos = checkpoint5
                _status = True
                # End Sep
                break
            # End Discard
            if not (_status):
                break
            staging16 = _result
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
            # End Ref
            if _status:
                _result = staging16
            break
        # End Discard
        if not (_status):
            break
        staging17 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, R, _pos))
        # End Ref
        if _status:
            _result = staging17
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_SurroundedList(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_SurroundedList, fullparse)

SurroundedList = ParsingRule('SurroundedList', _parse_SurroundedList, """
    SurroundedList(L, T, R) = (((L >> Pad) >> (T /? Comma)) << Pad) << R
""")
def _parse_function_517(_ctx, _text, _pos):
    # Begin Str
    value71 = '{'
    end71 = (_pos + 1)
    if (_text[slice(_pos, end71, None)] == value71):
        _result = value71
        _pos = (yield (3, _ctx._try__ignored, end71))[2]
        _status = True
    else:
        _result = _raise_error517
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_519(_ctx, _text, _pos):
    # Begin Str
    value72 = '}'
    end72 = (_pos + 1)
    if (_text[slice(_pos, end72, None)] == value72):
        _result = value72
        _pos = (yield (3, _ctx._try__ignored, end72))[2]
        _status = True
    else:
        _result = _raise_error519
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_CurlyList(_ctx, _text, _pos, T):
    # Rule 'CurlyList'
    # Begin Call
    # SurroundedList('{', T, '}')
    arg40 = _wrap_string_literal('{', _parse_function_517)
    arg41 = _wrap_string_literal('}', _parse_function_519)
    func45 = _ParseFunction(_ctx._try_SurroundedList, (arg40, T, arg41), ())
    (_status, _result, _pos) = (yield (3, func45, _pos))
    # End Call
    yield (_status, _result, _pos)

def _parse_CurlyList(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_CurlyList, fullparse)

CurlyList = ParsingRule('CurlyList', _parse_CurlyList, """
    CurlyList(T) = SurroundedList('{', T, '}')
""")
def _raise_error517(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'CurlyList' rule, at the expression:\n"
    "    '{'\n\n"
    "Expected to match the string '{'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error519(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'CurlyList' rule, at the expression:\n"
    "    '}'\n\n"
    "Expected to match the string '}'"
    )
    raise ParseError((title + details), _pos, line, col)

def _parse_function_523(_ctx, _text, _pos):
    # Begin Str
    value73 = '('
    end73 = (_pos + 1)
    if (_text[slice(_pos, end73, None)] == value73):
        _result = value73
        _pos = (yield (3, _ctx._try__ignored, end73))[2]
        _status = True
    else:
        _result = _raise_error523
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_525(_ctx, _text, _pos):
    # Begin Str
    value74 = ')'
    end74 = (_pos + 1)
    if (_text[slice(_pos, end74, None)] == value74):
        _result = value74
        _pos = (yield (3, _ctx._try__ignored, end74))[2]
        _status = True
    else:
        _result = _raise_error525
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_ParenthesesList(_ctx, _text, _pos, T):
    # Rule 'ParenthesesList'
    # Begin Call
    # SurroundedList('(', T, ')')
    arg42 = _wrap_string_literal('(', _parse_function_523)
    arg43 = _wrap_string_literal(')', _parse_function_525)
    func46 = _ParseFunction(_ctx._try_SurroundedList, (arg42, T, arg43), ())
    (_status, _result, _pos) = (yield (3, func46, _pos))
    # End Call
    yield (_status, _result, _pos)

def _parse_ParenthesesList(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_ParenthesesList, fullparse)

ParenthesesList = ParsingRule('ParenthesesList', _parse_ParenthesesList, """
    ParenthesesList(T) = SurroundedList('(', T, ')')
""")
def _raise_error523(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ParenthesesList' rule, at the expression:\n"
    "    '('\n\n"
    "Expected to match the string '('"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error525(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ParenthesesList' rule, at the expression:\n"
    "    ')'\n\n"
    "Expected to match the string ')'"
    )
    raise ParseError((title + details), _pos, line, col)

def _parse_function_529(_ctx, _text, _pos):
    # Begin Str
    value75 = '['
    end75 = (_pos + 1)
    if (_text[slice(_pos, end75, None)] == value75):
        _result = value75
        _pos = (yield (3, _ctx._try__ignored, end75))[2]
        _status = True
    else:
        _result = _raise_error529
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_531(_ctx, _text, _pos):
    # Begin Str
    value76 = ']'
    end76 = (_pos + 1)
    if (_text[slice(_pos, end76, None)] == value76):
        _result = value76
        _pos = (yield (3, _ctx._try__ignored, end76))[2]
        _status = True
    else:
        _result = _raise_error531
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_SquareList(_ctx, _text, _pos, T):
    # Rule 'SquareList'
    # Begin Call
    # SurroundedList('[', T, ']')
    arg44 = _wrap_string_literal('[', _parse_function_529)
    arg45 = _wrap_string_literal(']', _parse_function_531)
    func47 = _ParseFunction(_ctx._try_SurroundedList, (arg44, T, arg45), ())
    (_status, _result, _pos) = (yield (3, func47, _pos))
    # End Call
    yield (_status, _result, _pos)

def _parse_SquareList(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_SquareList, fullparse)

SquareList = ParsingRule('SquareList', _parse_SquareList, """
    SquareList(T) = SurroundedList('[', T, ']')
""")
def _raise_error529(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'SquareList' rule, at the expression:\n"
    "    '['\n\n"
    "Expected to match the string '['"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error531(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'SquareList' rule, at the expression:\n"
    "    ']'\n\n"
    "Expected to match the string ']'"
    )
    raise ParseError((title + details), _pos, line, col)

def _try__ignored(_ctx, _text, _pos):
    # Rule '_ignored'
    # Begin Skip
    # Skip(Space, Comment, LineExtension)
    while True:
        checkpoint6 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Space, _pos))
        # End Ref
        if _status:
            continue
        else:
            _pos = checkpoint6
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Comment, _pos))
        # End Ref
        if _status:
            continue
        else:
            _pos = checkpoint6
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_LineExtension, _pos))
        # End Ref
        if _status:
            continue
        else:
            _pos = checkpoint6
        break
    _result = None
    _status = True
    # End Skip
    yield (_status, _result, _pos)

def _parse__ignored(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try__ignored, fullparse)

_ignored = ParsingRule('_ignored', _parse__ignored, """
    _ignored = Skip(Space, Comment, LineExtension)
""")
_ctx = _Context()
_ctx._try__ignored = _try__ignored
_ctx._try_Space = _try_Space
_ctx._try_Comment = _try_Comment
_ctx._try_LineExtension = _try_LineExtension
_ctx._try_Pad = _try_Pad
_ctx._try_wrap = _try_wrap
_ctx._try_Word = _try_Word
_ctx._try_kw = _try_kw
_ctx._try_Name = _try_Name
_ctx._try_start = _try_start
_ctx._try_Definition = _try_Definition
_ctx._try_Class = _try_Class
_ctx._try_Function = _try_Function
_ctx._try_Graph = _try_Graph
_ctx._try_Node = _try_Node
_ctx._try_Edges = _try_Edges
_ctx._try_Edge = _try_Edge
_ctx._try_Handler = _try_Handler
_ctx._try_State = _try_State
_ctx._try_Statement = _try_Statement
_ctx._try_Assign = _try_Assign
_ctx._try_Emit = _try_Emit
_ctx._try_Forward = _try_Forward
_ctx._try_Return = _try_Return
_ctx._try_TypeExpression = _try_TypeExpression
_ctx._try_ValueExpression = _try_ValueExpression
_ctx._try_LiteralExpression = _try_LiteralExpression
_ctx._try_EmptyMapLiteral = _try_EmptyMapLiteral
_ctx._try_ListLiteral = _try_ListLiteral
_ctx._try_MapLiteral = _try_MapLiteral
_ctx._try_Pair = _try_Pair
_ctx._try_NumberLiteral = _try_NumberLiteral
_ctx._try_SetLiteral = _try_SetLiteral
_ctx._try_StringLiteral = _try_StringLiteral
_ctx._try_TupleLiteral = _try_TupleLiteral
_ctx._try_ArgumentList = _try_ArgumentList
_ctx._try_ElementAccess = _try_ElementAccess
_ctx._try_FieldAccess = _try_FieldAccess
_ctx._try_If = _try_If
_ctx._try_Match = _try_Match
_ctx._try_MatchCase = _try_MatchCase
_ctx._try_Block = _try_Block
_ctx._try_Comma = _try_Comma
_ctx._try_LineSep = _try_LineSep
_ctx._try_Lines = _try_Lines
_ctx._try_Parameter = _try_Parameter
_ctx._try_SurroundedList = _try_SurroundedList
_ctx._try_CurlyList = _try_CurlyList
_ctx._try_ParenthesesList = _try_ParenthesesList
_ctx._try_SquareList = _try_SquareList
_ctx._try__ignored = _try__ignored
