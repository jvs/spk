# Generated by ../generate_parser.py
"""
# Grammar definition:
grammar spk

`from ast import literal_eval`

ignore Space = /[ \\t]+/
ignore Comment = /#[^\\r\\n]*/
ignore LineExtension = /\\.\\.\\.[ \\t\\r\\n]+/

CheckedSpace = Backtrack(1) >> Space
ForbiddenSpace(x) = ExpectNot(CheckedSpace) >> x
RequiredSpace(x) = CheckedSpace >> x << CheckedSpace

Pad = /[ \\t\\r\\n]+/*

wrap(x) => Pad >> (x) << Pad

# Allow "-" to appear in names. Use spaces around subtraction to disambiguate.
Word = /[_a-zA-Z][_a-zA-Z0-9\\-]*/

# Parse a full word, then see if it matches our keyword. The point is to make
# sure that we don't simply match the first part of a word. (For example, if
# the input string is "notice", we wouldn't want to match the keyword "not".)
kw(word) => Word where `lambda x: x == word`

```
keywords = [
    'and',
    'else',
    'emit',
    'if',
    'match',
    'not',
    'on',
    'or',
    'press',
    'release',
    'return',
    'then',
    'to',
]
```

Name = Word where `lambda x: x not in keywords`

start = wrap(Lines(Assign | Definition | Template)) << ExpectNot(/./)


# Top-level definitions.

Definition = Class | Function | Graph | Node

class Class {
    pass kw("class")
    name: Opt(Name)
    parameters: Block(Parameter)
}

class Function {
    pass kw("function")
    name: Opt(Name)
    parameters: ParenthesesList(Parameter)
    returns: Opt(":" >> TypeExpression)
    body: Block(Statement)
}

class Graph {
    pass kw("graph")
    name: Opt(Name)
    body: Block(Assign | Config | Edges | Function | Node | State)
}

class Node {
    pass kw("node")
    name: Opt(Name)
    body: Block(Assign | Config | Function | Handler | State)
}

class Template {
    pass kw("template")
    name: Name
    parameters: ParenthesesList(Parameter)
    returns: Opt(":" >> TypeExpression)
    body: Block(Statement)
}

AnonymousDefinition = Definition where `lambda x: x.name is None`


## Elements of a graph.

class Edges {
    pass kw("edges")
    body: Block(ConditionalEdges | Edge)
}

class ConditionalEdges {
    pass kw("if")
    condition: ValueExpression
    body: Block(ConditionalEdges | Edge)
}

class Edge {
    nodes: Sep(Word, wrap(">>"), allow_empty=False)
}


## Elements of a node.

class Config {
    pass kw("config")
    name: Opt(Name)
    body: Block(Parameter)
}

class Handler {
    pass kw("on")
    action: Word
    parameters: ParenthesesList(Parameter)
    body: Block(Statement)
}

class State {
    pass kw("state")
    name: Opt(Name)
    body: Block(Parameter)
}


## Statements.

Statement = (
    Assign
    | Emit
    | For
    | Operate
    | Return
    | ValueExpression
)

class Assign {
    storage: ValueExpression | Names
    operator: (
        "="
        | "+="
        | "-="
        | "*="
        | "/="
        | "%="
        | "<<="
        | ">>="
        | "&="
        | "^="
        | "|="
    )
    value: AnonymousDefinition | ValueExpression
}

class Emit {
    pass Opt("emit")
    key: ValueExpression
    target: Opt("to" >> ValueExpression)
}

class For {
    pass kw("for")
    names: Names
    pass kw("in")
    source: ValueExpression
    guard: Opt(Pad >> kw("if") >> ValueExpression)
    body: Block(Statement)
}

class Operate {
    action: "press" | "release"
    key: ValueExpression
    target: Opt("to" >> ValueExpression)
}

class Return {
    pass kw("return")
    value: Opt(ValueExpression)
}


## Type-level expressions.

# Just use the same syntax as for values.
TypeExpression = ValueExpression


## Value-level expressions.

ValueExpression = (Name | LiteralExpression) between {
    mixfix: "(" >> wrap(ValueExpression) << ")"
    postfix: ArgumentList, ElementAccess, FieldAccess, GenericArgumentList
    prefix: "-"
    left: "*", "/", "%"
    left: "+", "-"
    infix: wrap("<<"), wrap(">>")
    infix: "<=", ">=", RequiredSpace("<" | ">")
    infix: "in", NotIn
    infix: "==", "!="
    left: "&"
    left: "^"
    left: wrap("|")
    prefix: kw("not")
    left: wrap(kw("and"))
    left: wrap(kw("or"))
    mixfix: If, Match
}

NotIn = /not[ \\t]+in/ >> `'not in'`


## Literal expressions.

LiteralExpression = (
    EmptyMapLiteral
    | ListLiteral
    | MapLiteral
    | NumberLiteral
    | SetLiteral
    | SymbolLiteral
    | TupleLiteral
)

class EmptyMapLiteral {
    pass "{" >> wrap(":") << "}"
}

class ListLiteral {
    elements: SquareList(ValueExpression)
}

class MapLiteral {
    pairs: CurlyList(Pair)
}

class Pair {
    key: ValueExpression
    value: ":" >> ValueExpression
}

class NumberLiteral {
    value: /\\d+(\\.\\d*)?|\\.\\d+/
}

class SetLiteral {
    elements: CurlyList(ValueExpression)
}

class SymbolLiteral {
    contents: /"(?:[^\\\\"]|\\\\.)*"/ |> `literal_eval`
}

class TupleLiteral {
    pass "("
    elements: wrap(Sep(
        ValueExpression,
        Comma,
        allow_trailer=true,
        require_separator=true,
    ))
    pass ")"
}


## Postfix operators.

class ArgumentList {
    arguments: ParenthesesList(ValueExpression | KeywordArgument)
}

class GenericArgumentList {
    arguments: ForbiddenSpace("<") >> (GenericArgument /? Comma) << ForbiddenSpace(">")
}

GenericArgument = KeywordTypeArgument | TypeExpression

class KeywordArgument {
    name: Word
    pass "="
    value: ValueExpression
}

class KeywordTypeArgument {
    name: Word
    pass "="
    value: TypeExpression
}

class ElementAccess {
    indexes: SquareList(ValueExpression)
}

class FieldAccess {
    field: "." >> Word
}


## Mixfix operators.

class If {
    pass kw("if")
    condition: ValueExpression
    then_branch: Block(Statement)
    else_branch: Opt(kw("else") >> Block(Statement))
}

class Match {
    pass kw("match")
    value: ValueExpression
    cases: Block(MatchCase)
}

class MatchCase {
    pass kw("case")
    pattern: Opt(ValueExpression | "*")
    guard: Opt(kw("if") >> ValueExpression)
    body: Block(Statement)
}


## Common structures.

# TODO: Figure out why "wrap" doesn't work here.
Block(T) => Pad >> "{" >> Pad >> (T /? LineSep) << Pad << "}"

Comma = wrap(",")

LineSep = /[\\n\\r]+/+

Lines(T) = (T /? LineSep)

class Parameter {
    name: Name
    type: Opt(":" >> TypeExpression)
    default: Opt("=" >> ValueExpression)
}

Names = (Name /? Comma) | ParenthesesList(Name)


### List structures.

# TODO: Figure out why "wrap" doesn't work here.
SurroundedList(L, T, R) => L >> Pad >> (T /? Comma) << Pad << R

CurlyList(T) => SurroundedList("{", T, "}")
ParenthesesList(T) => SurroundedList("(", T, ")")
SquareList(T) => SurroundedList("[", T, "]")

"""

from collections import namedtuple as _nt
from re import compile as _compile_re, IGNORECASE as _IGNORECASE

class ParsedObject:
    _fields = ()

    def __init__(self):
        self._metadata = _Metadata()
        self._hash = None

    def __eq__(self, other):
        if self is other:
            return True
        if not isinstance(other, self.__class__):
            return False
        for field in self._fields:
            left = getattr(self, field)
            right = getattr(other, field)
            if left is not right and left != right:
                return False
        return True

    def __hash__(self):
        if self._hash is not None:
            return self._hash
        self._hash = 0
        result = 0
        for field in self._fields:
            result ^= _hash(getattr(self, field))
        self._hash = result
        return result

    def _asdict(self):
        return {k: getattr(self, k) for k in self._fields}

    def _replace(self, **kw):
        for field in self._fields:
            if field not in kw:
                kw[field] = getattr(self, field)
        result = self.__class__(**kw)
        result._metadata.update(self._metadata)
        return result


def _hash(value):
    try:
        return hash(value)
    except TypeError:
        if isinstance(value, (tuple, list)):
            result = 0
            for item in value:
                result ^= _hash(item)
            return result
        elif isinstance(value, dict):
            result = 0
            for pair in value.items():
                result ^= _hash(pair)
            return result
        else:
            raise


class _Metadata:
    def __init__(self, **fields):
        object.__setattr__(self, '_fields', fields)

    def __getattr__(self, name):
        return self._fields.get(name)

    def __setattr__(self, name, value):
        self._fields[name] = value

    def __len__(self):
        return len(self._fields)

    def copy(self):
        return _Metadata(**self._fields)

    def update(self, other):
        self._fields.update(other._fields)


class ParsingRule:
    def __init__(self, name, parse, definition):
        self.name = name
        self.parse = parse
        self.definition = definition

    def __repr__(self):
        return (f'ParsingRule(name={self.name!r}, parse={self.parse.__name__},'
            f' definition={self.definition!r})')


class _Context:
    pass

from ast import literal_eval

keywords = [
    'and',
    'else',
    'emit',
    'if',
    'match',
    'not',
    'on',
    'or',
    'press',
    'release',
    'return',
    'then',
    'to',
]


class InputError(Exception):
    """Common superclass for ParseError and PartialParseError."""


class ParseError(InputError):
    def __init__(self, message, index, line, column):
        super().__init__(message)
        self.position = _Position(index, line, column)


class PartialParseError(InputError):
    def __init__(self, partial_result, last_position, excerpt):
        super().__init__('Incomplete parse. Unexpected input on line'
            f' {last_position.line}, column {last_position.column}:\n{excerpt}')
        self.partial_result = partial_result
        self.last_position = last_position


class Infix(ParsedObject):
    _fields = ('left', 'operator', 'right')

    def __init__(self, left, operator, right):
        ParsedObject.__init__(self)
        self.left = left
        self.operator = operator
        self.right = right

    def __repr__(self):
        return f'Infix({self.left!r}, {self.operator!r}, {self.right!r})'


class Postfix(ParsedObject):
    _fields = ('left', 'operator')

    def __init__(self, left, operator):
        ParsedObject.__init__(self)
        self.left = left
        self.operator = operator

    def __repr__(self):
        return f'Postfix({self.left!r}, {self.operator!r})'


class Prefix(ParsedObject):
    _fields = ('operator', 'right')

    def __init__(self, operator, right):
        ParsedObject.__init__(self)
        self.operator = operator
        self.right = right

    def __repr__(self):
        return f'Prefix({self.operator!r}, {self.right!r})'


def parse(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_start, fullparse)


_PositionInfo = _nt('_PositionInfo', 'start, end')

_Position = _nt('_Position', 'index, line, column')


class _ParseFunction(_nt('_ParseFunction', 'func, args, kwargs')):
    def __call__(self, _ctx, _text, _pos):
        return self.func(_ctx, _text, _pos, *self.args, **dict(self.kwargs))


class _StringLiteral(str):
    def __call__(self, _ctx, _text, _pos):
        return self._parse_function(_ctx, _text, _pos)


def _wrap_string_literal(string_value, parse_function):
    result = _StringLiteral(string_value)
    result._parse_function = parse_function
    return result


class _ByteLiteral(int):
    def __call__(self, _ctx, _text, _pos):
        return self._parse_function(_ctx, _text, _pos)


def _wrap_byte_literal(byte_value, parse_function):
    result = _ByteLiteral(byte_value)
    result._parse_function = parse_function
    return result


def _run(_ctx, text, pos, start, fullparse):
    memo = {}
    result = None

    key = (3, start, pos)
    gtor = start(_ctx, text, pos)
    stack = [(key, gtor)]

    while stack:
        key, gtor = stack[-1]
        result = gtor.send(result)

        if result[0] != 3:
            stack.pop()
            memo[key] = result
        elif result in memo:
            result = memo[result]
        else:
            gtor = result[1](_ctx, text, result[2])
            stack.append((result, gtor))
            result = None

    if result[0]:
        return _finalize_parse_info(text, result[1], result[2], fullparse)
    else:
        pos = result[2]
        message = result[1](text, pos)
        raise ParseError(message, pos)


def visit(node):
    visited = set()
    stack = [node]
    while stack:
        node = stack.pop()

        if isinstance(node, (list, tuple)):
            stack.extend(reversed(node))

        elif isinstance(node, dict):
            stack.extend(reversed(node.values()))

        elif isinstance(node, ParsedObject):
            node_id = id(node)
            if node_id in visited:
                continue
            visited.add(node_id)

            yield node

            if hasattr(node, '_fields'):
                stack.extend(getattr(node, x) for x in reversed(node._fields))


_Traversing = _nt('_Traversing', 'parent, field, child, is_finished')


def traverse(node):
    visited = set()
    stack = [_Traversing(parent=None, field=None, child=node, is_finished=False)]
    while stack:
        traversing = stack.pop()

        if traversing.is_finished:
            yield traversing
            continue

        child = traversing.child
        child_id = id(child)

        if child_id in visited:
            continue

        visited.add(child_id)
        stack.append(traversing._replace(is_finished=True))
        yield traversing

        def extend(items):
            stack.extend(reversed(list(items)))

        if isinstance(child, (list, tuple)):
            extend(
                _Traversing(parent=child, field=i, child=x, is_finished=False)
                for i, x in enumerate(child)
            )

        elif isinstance(child, dict):
            extend(
                _Traversing(parent=child, field=k, child=v, is_finished=False)
                for k, v in child.items()
            )

        elif isinstance(child, ParsedObject) and hasattr(child, '_fields'):
            extend(
                _Traversing(
                    parent=child,
                    field=x,
                    child=getattr(child, x),
                    is_finished=False,
                )
                for x in child._fields
            )


def transform(node, *callbacks):
    if not callbacks:
        return node

    def callback(node):
        for f in callbacks:
            prev = node
            node = f(prev)

            if node is not prev:
                if (
                    isinstance(prev, ParsedObject)
                    and isinstance(node, ParsedObject)
                    and not node._metadata
                ):
                    node._metadata.update(prev._metadata)

        return node

    return _transform(node, callback)


def _transform(node, callback):
    if isinstance(node, list):
        return [_transform(x, callback) for x in node]

    if not isinstance(node, ParsedObject):
        return node

    updates = {}
    for field in node._fields:
        was = getattr(node, field)
        now = _transform(was, callback)
        if now is not was:
            updates[field] = now

    if updates:
        node = node._replace(**updates)

    return callback(node)


def _finalize_parse_info(text, nodes, pos, fullparse):
    line_numbers, column_numbers = _map_index_to_line_and_column(text)

    for node in visit(nodes):
        pos_info = node._metadata.position_info
        if pos_info:
            start, end = pos_info
            end -= 1
            node._metadata.position_info = _PositionInfo(
                start=_Position(start, line_numbers[start], column_numbers[start]),
                end=_Position(end, line_numbers[end], column_numbers[end]),
            )

    if fullparse and pos < len(text):
        line, col = line_numbers[pos], column_numbers[pos]
        position = _Position(pos, line, col)
        excerpt = _extract_excerpt(text, pos, col)
        raise PartialParseError(nodes, position, excerpt)

    return nodes


def _extract_excerpt(text, pos, col):
    if isinstance(text, bytes):
        return repr(text[max(0, pos - 1) : pos + 2])

    start = pos - (col - 1)
    match = _compile_re('\n').search(text, pos + 1)
    end = len(text) if match is None else match.start()

    if end - start < 96:
        return text[start : end] + _caret_at(col - 1)

    if col < 60:
        # Chop the line off at the end.
        return text[start : start + 90] + ' ...' + _caret_at(col - 1)

    elif end - pos < 40:
        # Chop the line off at the start.
        return '... ' + text[end - 90 : end] + _caret_at(pos - (end - 90) + 4)

    else:
        # Chop the line off at both ends.
        return '... ' + text[pos - 42 : pos + 42] + ' ...' + _caret_at(42 + 4)


def _caret_at(index):
    return '\n' + (' ' * index) + '^'


def _get_line_and_column(text, pos):
    line_numbers, column_numbers = _map_index_to_line_and_column(text)
    return line_numbers[pos], column_numbers[pos]


def _map_index_to_line_and_column(text):
    line_numbers = []
    column_numbers = []

    current_line = 1
    current_column = 0

    for c in text:
        if c == '\n':
            current_line += 1
            current_column = 0
        else:
            current_column += 1
        line_numbers.append(current_line)
        column_numbers.append(current_column)

    return line_numbers, column_numbers

matcher1 = _compile_re('[ \\t]+', flags=0).match
matcher2 = _compile_re('#[^\\r\\n]*', flags=0).match
matcher3 = _compile_re('\\.\\.\\.[ \\t\\r\\n]+', flags=0).match
matcher4 = _compile_re('[ \\t\\r\\n]+', flags=0).match
matcher5 = _compile_re('[_a-zA-Z][_a-zA-Z0-9\\-]*', flags=0).match
matcher6 = _compile_re('.', flags=0).match
matcher7 = _compile_re('not[ \\t]+in', flags=0).match
matcher8 = _compile_re('\\d+(\\.\\d*)?|\\.\\d+', flags=0).match
matcher9 = _compile_re('"(?:[^\\\\"]|\\\\.)*"', flags=0).match
matcher10 = _compile_re('[\\n\\r]+', flags=0).match

def _try_Space(_ctx, _text, _pos):
    # Rule 'Space'
    # Begin Regex
    # /[ \\t]+/
    match1 = matcher1(_text, _pos)
    if match1:
        _result = match1.group(0)
        _pos = (yield (3, _ctx._try__ignored, match1.end()))[2]
        _status = True
    else:
        _result = _raise_error2
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_Space(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Space, fullparse)

Space = ParsingRule('Space', _parse_Space, """
    Space = /[ \\t]+/
""")
def _raise_error2(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Space' rule, at the expression:\n"
    '    /[ \\\\t]+/\n\n'
    'Expected to match the regular expression /[ \\t]+/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Comment(_ctx, _text, _pos):
    # Rule 'Comment'
    # Begin Regex
    # /#[^\\r\\n]*/
    match2 = matcher2(_text, _pos)
    if match2:
        _result = match2.group(0)
        _pos = (yield (3, _ctx._try__ignored, match2.end()))[2]
        _status = True
    else:
        _result = _raise_error4
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_Comment(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Comment, fullparse)

Comment = ParsingRule('Comment', _parse_Comment, """
    Comment = /#[^\\r\\n]*/
""")
def _raise_error4(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Comment' rule, at the expression:\n"
    '    /#[^\\\\r\\\\n]*/\n\n'
    'Expected to match the regular expression /#[^\\r\\n]*/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_LineExtension(_ctx, _text, _pos):
    # Rule 'LineExtension'
    # Begin Regex
    # /\\.\\.\\.[ \\t\\r\\n]+/
    match3 = matcher3(_text, _pos)
    if match3:
        _result = match3.group(0)
        _pos = (yield (3, _ctx._try__ignored, match3.end()))[2]
        _status = True
    else:
        _result = _raise_error6
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_LineExtension(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_LineExtension, fullparse)

LineExtension = ParsingRule('LineExtension', _parse_LineExtension, """
    LineExtension = /\\.\\.\\.[ \\t\\r\\n]+/
""")
def _raise_error6(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'LineExtension' rule, at the expression:\n"
    '    /\\\\.\\\\.\\\\.[ \\\\t\\\\r\\\\n]+/\n\n'
    'Expected to match the regular expression /\\.\\.\\.[ \\t\\r\\n]+/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_CheckedSpace(_ctx, _text, _pos):
    # Rule 'CheckedSpace'
    # Begin Discard
    # Backtrack(1) >> Space
    while True:
        # Begin Backtrack
        # Backtrack(1)
        if (_pos >= 1):
            _pos = (_pos - 1)
            _status = True
            _result = None
        else:
            _status = False
            _result = _raise_error9
        # End Backtrack
        if not (_status):
            break
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Space, _pos))
        # End Ref
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_CheckedSpace(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_CheckedSpace, fullparse)

CheckedSpace = ParsingRule('CheckedSpace', _parse_CheckedSpace, """
    CheckedSpace = Backtrack(1) >> Space
""")
def _raise_error9(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'CheckedSpace' rule, at the expression:\n"
    '    Backtrack(1)\n\n'
    'Cannot backtrack by 1, unexpected start of input.'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_ForbiddenSpace(_ctx, _text, _pos, x):
    # Rule 'ForbiddenSpace'
    # Begin Discard
    # ExpectNot(CheckedSpace) >> x
    while True:
        # Begin ExpectNot
        # ExpectNot(CheckedSpace)
        backtrack1 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_CheckedSpace, _pos))
        # End Ref
        _pos = backtrack1
        if _status:
            _status = False
            _result = _raise_error13
        else:
            _status = True
            _result = None
        # End ExpectNot
        if not (_status):
            break
        # Begin Ref
        (_status, _result, _pos) = (yield (3, x, _pos))
        # End Ref
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_ForbiddenSpace(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_ForbiddenSpace, fullparse)

ForbiddenSpace = ParsingRule('ForbiddenSpace', _parse_ForbiddenSpace, """
    ForbiddenSpace(x) = ExpectNot(CheckedSpace) >> x
""")
def _raise_error13(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ForbiddenSpace' rule, at the expression:\n"
    '    ExpectNot(CheckedSpace)\n\n'
    'Did not expect to match: CheckedSpace'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_RequiredSpace(_ctx, _text, _pos, x):
    # Rule 'RequiredSpace'
    # Begin Discard
    # (CheckedSpace >> x) << CheckedSpace
    while True:
        # Begin Discard
        # CheckedSpace >> x
        while True:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_CheckedSpace, _pos))
            # End Ref
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, x, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            break
        staging1 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_CheckedSpace, _pos))
        # End Ref
        if _status:
            _result = staging1
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_RequiredSpace(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_RequiredSpace, fullparse)

RequiredSpace = ParsingRule('RequiredSpace', _parse_RequiredSpace, """
    RequiredSpace(x) = (CheckedSpace >> x) << CheckedSpace
""")
def _try_Pad(_ctx, _text, _pos):
    # Rule 'Pad'
    # Begin List
    # /[ \\t\\r\\n]+/*
    staging2 = []
    while True:
        # Begin Regex
        # /[ \\t\\r\\n]+/
        match4 = matcher4(_text, _pos)
        if match4:
            _result = match4.group(0)
            _pos = (yield (3, _ctx._try__ignored, match4.end()))[2]
            _status = True
        else:
            _result = _raise_error24
            _status = False
        # End Regex
        if not (_status):
            break
        staging2.append(_result)
    _result = staging2
    _status = True
    # End List
    yield (_status, _result, _pos)

def _parse_Pad(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Pad, fullparse)

Pad = ParsingRule('Pad', _parse_Pad, """
    Pad = /[ \\t\\r\\n]+/*
""")
def _raise_error24(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Pad' rule, at the expression:\n"
    '    /[ \\\\t\\\\r\\\\n]+/\n\n'
    'Expected to match the regular expression /[ \\t\\r\\n]+/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_wrap(_ctx, _text, _pos, x):
    # Rule 'wrap'
    # Begin Discard
    # (Pad >> x) << Pad
    while True:
        # Begin Discard
        # Pad >> x
        while True:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
            # End Ref
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, x, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            break
        staging3 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
        # End Ref
        if _status:
            _result = staging3
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_wrap(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_wrap, fullparse)

wrap = ParsingRule('wrap', _parse_wrap, """
    wrap(x) = (Pad >> x) << Pad
""")
def _try_Word(_ctx, _text, _pos):
    # Rule 'Word'
    # Begin Regex
    # /[_a-zA-Z][_a-zA-Z0-9\\-]*/
    match5 = matcher5(_text, _pos)
    if match5:
        _result = match5.group(0)
        _pos = (yield (3, _ctx._try__ignored, match5.end()))[2]
        _status = True
    else:
        _result = _raise_error32
        _status = False
    # End Regex
    yield (_status, _result, _pos)

def _parse_Word(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Word, fullparse)

Word = ParsingRule('Word', _parse_Word, """
    Word = /[_a-zA-Z][_a-zA-Z0-9\\-]*/
""")
def _raise_error32(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Word' rule, at the expression:\n"
    '    /[_a-zA-Z][_a-zA-Z0-9\\\\-]*/\n\n'
    'Expected to match the regular expression /[_a-zA-Z][_a-zA-Z0-9\\-]*/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_kw(_ctx, _text, _pos, word):
    # Rule 'kw'
    # Begin Where
    # Word where `lambda x: x == word`
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _ctx._try_Word, _pos))
    # End Ref
    if _status:
        arg1 = _result
        _result = lambda x: x == word
        _status = True
        if _result(arg1):
            _result = arg1
        else:
            _result = _raise_error34
            _status = False
    # End Where
    yield (_status, _result, _pos)

def _parse_kw(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_kw, fullparse)

kw = ParsingRule('kw', _parse_kw, """
    kw(word) = Word where `lambda x: x == word`
""")
def _raise_error34(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'kw' rule, at the expression:\n"
    '    Word where `lambda x: x == word`\n\n'
    'Expected to satisfy the predicate: `lambda x: x == word`'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Name(_ctx, _text, _pos):
    # Rule 'Name'
    # Begin Where
    # Word where `lambda x: x not in keywords`
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _ctx._try_Word, _pos))
    # End Ref
    if _status:
        arg2 = _result
        _result = lambda x: x not in keywords
        _status = True
        if _result(arg2):
            _result = arg2
        else:
            _result = _raise_error38
            _status = False
    # End Where
    yield (_status, _result, _pos)

def _parse_Name(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Name, fullparse)

Name = ParsingRule('Name', _parse_Name, """
    Name = Word where `lambda x: x not in keywords`
""")
def _raise_error38(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Name' rule, at the expression:\n"
    '    Word where `lambda x: x not in keywords`\n\n'
    'Expected to satisfy the predicate: `lambda x: x not in keywords`'
    )
    raise ParseError((title + details), _pos, line, col)

def _parse_function_49(_ctx, _text, _pos):
    # Begin Choice
    farthest_err1 = _raise_error49
    backtrack2 = farthest_pos1 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Assign, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = backtrack2
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Definition, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = backtrack2
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Template, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos1 < _pos):
            farthest_pos1 = _pos
            farthest_err1 = _result
        _pos = farthest_pos1
        _result = farthest_err1
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_function_47(_ctx, _text, _pos):
    # Begin Call
    # Lines(Assign | Definition | Template)
    func1 = _ParseFunction(_ctx._try_Lines, (_parse_function_49,), ())
    (_status, _result, _pos) = (yield (3, func1, _pos))
    # End Call
    yield (_status, _result, _pos)

def _try_start(_ctx, _text, _pos):
    # Rule 'start'
    # Begin Discard
    # _try__ignored >> (wrap(Lines(Assign | Definition | Template)) << ExpectNot(/./))
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try__ignored, _pos))
        # End Ref
        if not (_status):
            break
        # Begin Discard
        # wrap(Lines(Assign | Definition | Template)) << ExpectNot(/./)
        while True:
            # Begin Call
            # wrap(Lines(Assign | Definition | Template))
            func2 = _ParseFunction(_ctx._try_wrap, (_parse_function_47,), ())
            (_status, _result, _pos) = (yield (3, func2, _pos))
            # End Call
            if not (_status):
                break
            staging4 = _result
            # Begin ExpectNot
            # ExpectNot(/./)
            backtrack3 = _pos
            # Begin Regex
            # /./
            match6 = matcher6(_text, _pos)
            if match6:
                _result = match6.group(0)
                _pos = (yield (3, _ctx._try__ignored, match6.end()))[2]
                _status = True
            else:
                _result = _raise_error54
                _status = False
            # End Regex
            _pos = backtrack3
            if _status:
                _status = False
                _result = _raise_error53
            else:
                _status = True
                _result = None
            # End ExpectNot
            if _status:
                _result = staging4
            break
        # End Discard
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_start(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_start, fullparse)

start = ParsingRule('start', _parse_start, """
    start = _try__ignored >> (wrap(Lines(Assign | Definition | Template)) << ExpectNot(/./))
""")
def _raise_error49(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'start' rule, at the expression:\n"
    '    Assign | Definition | Template\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error53(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'start' rule, at the expression:\n"
    '    ExpectNot(/./)\n\n'
    'Did not expect to match: /./'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error54(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'start' rule, at the expression:\n"
    '    /./\n\n'
    'Expected to match the regular expression /./'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Definition(_ctx, _text, _pos):
    # Rule 'Definition'
    # Begin Choice
    farthest_err2 = _raise_error56
    backtrack4 = farthest_pos2 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Class, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos2 < _pos):
            farthest_pos2 = _pos
            farthest_err2 = _result
        _pos = backtrack4
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Function, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos2 < _pos):
            farthest_pos2 = _pos
            farthest_err2 = _result
        _pos = backtrack4
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Graph, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos2 < _pos):
            farthest_pos2 = _pos
            farthest_err2 = _result
        _pos = backtrack4
        # Option 4:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Node, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos2 < _pos):
            farthest_pos2 = _pos
            farthest_err2 = _result
        _pos = farthest_pos2
        _result = farthest_err2
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_Definition(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Definition, fullparse)

Definition = ParsingRule('Definition', _parse_Definition, """
    Definition = Class | Function | Graph | Node
""")
def _raise_error56(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Definition' rule, at the expression:\n"
    '    Class | Function | Graph | Node\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class Class(ParsedObject):
    """
    class Class {
        pass kw('class')
        name: Opt(Name)
        parameters: Block(Parameter)
    }
    """
    _fields = ('name', 'parameters')

    def __init__(self, name, parameters):
        ParsedObject.__init__(self)
        self.name = name
        self.parameters = parameters

    def __repr__(self):
        return f'Class(name={self.name!r}, parameters={self.parameters!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Class, fullparse)


def _parse_function_66(_ctx, _text, _pos):
    # Begin Str
    value1 = 'class'
    end1 = (_pos + 5)
    if (_text[slice(_pos, end1, None)] == value1):
        _result = value1
        _pos = (yield (3, _ctx._try__ignored, end1))[2]
        _status = True
    else:
        _result = _raise_error66
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Class(_ctx, _text, _pos):
    # Begin Seq
    start_pos1 = _pos
    while True:
        # Begin Call
        # kw('class')
        arg3 = _wrap_string_literal('class', _parse_function_66)
        func3 = _ParseFunction(_ctx._try_kw, (arg3,), ())
        (_status, _result, _pos) = (yield (3, func3, _pos))
        # End Call
        if not (_status):
            break
        item1 = _result
        # Begin Opt
        # Opt(Name)
        backtrack5 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack5
            _result = None
            _status = True
        # End Opt
        name = _result
        # Begin Call
        # Block(Parameter)
        func4 = _ParseFunction(_ctx._try_Block, (_try_Parameter,), ())
        (_status, _result, _pos) = (yield (3, func4, _pos))
        # End Call
        if not (_status):
            break
        parameters = _result
        _result = Class(name, parameters)
        _result._metadata.position_info = (start_pos1, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error66(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Class' rule, at the expression:\n"
    "    'class'\n\n"
    "Expected to match the string 'class'"
    )
    raise ParseError((title + details), _pos, line, col)

class Function(ParsedObject):
    """
    class Function {
        pass kw('function')
        name: Opt(Name)
        parameters: ParenthesesList(Parameter)
        returns: Opt(':' >> TypeExpression)
        body: Block(Statement)
    }
    """
    _fields = ('name', 'parameters', 'returns', 'body')

    def __init__(self, name, parameters, returns, body):
        ParsedObject.__init__(self)
        self.name = name
        self.parameters = parameters
        self.returns = returns
        self.body = body

    def __repr__(self):
        return f'Function(name={self.name!r}, parameters={self.parameters!r}, returns={self.returns!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Function, fullparse)


def _parse_function_79(_ctx, _text, _pos):
    # Begin Str
    value2 = 'function'
    end2 = (_pos + 8)
    if (_text[slice(_pos, end2, None)] == value2):
        _result = value2
        _pos = (yield (3, _ctx._try__ignored, end2))[2]
        _status = True
    else:
        _result = _raise_error79
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Function(_ctx, _text, _pos):
    # Begin Seq
    start_pos2 = _pos
    while True:
        # Begin Call
        # kw('function')
        arg4 = _wrap_string_literal('function', _parse_function_79)
        func5 = _ParseFunction(_ctx._try_kw, (arg4,), ())
        (_status, _result, _pos) = (yield (3, func5, _pos))
        # End Call
        if not (_status):
            break
        item2 = _result
        # Begin Opt
        # Opt(Name)
        backtrack6 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack6
            _result = None
            _status = True
        # End Opt
        name = _result
        # Begin Call
        # ParenthesesList(Parameter)
        func6 = _ParseFunction(_ctx._try_ParenthesesList, (_try_Parameter,), ())
        (_status, _result, _pos) = (yield (3, func6, _pos))
        # End Call
        if not (_status):
            break
        parameters = _result
        # Begin Opt
        # Opt(':' >> TypeExpression)
        backtrack7 = _pos
        # Begin Discard
        # ':' >> TypeExpression
        while True:
            # Begin Str
            value3 = ':'
            end3 = (_pos + 1)
            if (_text[slice(_pos, end3, None)] == value3):
                _result = value3
                _pos = (yield (3, _ctx._try__ignored, end3))[2]
                _status = True
            else:
                _result = _raise_error90
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_TypeExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack7
            _result = None
            _status = True
        # End Opt
        returns = _result
        # Begin Call
        # Block(Statement)
        func7 = _ParseFunction(_ctx._try_Block, (_try_Statement,), ())
        (_status, _result, _pos) = (yield (3, func7, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = Function(name, parameters, returns, body)
        _result._metadata.position_info = (start_pos2, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error79(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Function' rule, at the expression:\n"
    "    'function'\n\n"
    "Expected to match the string 'function'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error90(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Function' rule, at the expression:\n"
    "    ':'\n\n"
    "Expected to match the string ':'"
    )
    raise ParseError((title + details), _pos, line, col)

class Graph(ParsedObject):
    """
    class Graph {
        pass kw('graph')
        name: Opt(Name)
        body: Block(Assign | Config | Edges | Function | Node | State)
    }
    """
    _fields = ('name', 'body')

    def __init__(self, name, body):
        ParsedObject.__init__(self)
        self.name = name
        self.body = body

    def __repr__(self):
        return f'Graph(name={self.name!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Graph, fullparse)


def _parse_function_101(_ctx, _text, _pos):
    # Begin Str
    value4 = 'graph'
    end4 = (_pos + 5)
    if (_text[slice(_pos, end4, None)] == value4):
        _result = value4
        _pos = (yield (3, _ctx._try__ignored, end4))[2]
        _status = True
    else:
        _result = _raise_error101
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_108(_ctx, _text, _pos):
    # Begin Choice
    farthest_err3 = _raise_error108
    backtrack9 = farthest_pos3 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Assign, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos3 < _pos):
            farthest_pos3 = _pos
            farthest_err3 = _result
        _pos = backtrack9
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Config, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos3 < _pos):
            farthest_pos3 = _pos
            farthest_err3 = _result
        _pos = backtrack9
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Edges, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos3 < _pos):
            farthest_pos3 = _pos
            farthest_err3 = _result
        _pos = backtrack9
        # Option 4:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Function, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos3 < _pos):
            farthest_pos3 = _pos
            farthest_err3 = _result
        _pos = backtrack9
        # Option 5:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Node, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos3 < _pos):
            farthest_pos3 = _pos
            farthest_err3 = _result
        _pos = backtrack9
        # Option 6:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_State, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos3 < _pos):
            farthest_pos3 = _pos
            farthest_err3 = _result
        _pos = farthest_pos3
        _result = farthest_err3
        break
    # End Choice
    yield (_status, _result, _pos)

def _try_Graph(_ctx, _text, _pos):
    # Begin Seq
    start_pos3 = _pos
    while True:
        # Begin Call
        # kw('graph')
        arg5 = _wrap_string_literal('graph', _parse_function_101)
        func8 = _ParseFunction(_ctx._try_kw, (arg5,), ())
        (_status, _result, _pos) = (yield (3, func8, _pos))
        # End Call
        if not (_status):
            break
        item3 = _result
        # Begin Opt
        # Opt(Name)
        backtrack8 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack8
            _result = None
            _status = True
        # End Opt
        name = _result
        # Begin Call
        # Block(Assign | Config | Edges | Function | Node | State)
        func9 = _ParseFunction(_ctx._try_Block, (_parse_function_108,), ())
        (_status, _result, _pos) = (yield (3, func9, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = Graph(name, body)
        _result._metadata.position_info = (start_pos3, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error101(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Graph' rule, at the expression:\n"
    "    'graph'\n\n"
    "Expected to match the string 'graph'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error108(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Graph' rule, at the expression:\n"
    '    Assign | Config | Edges | Function | Node | State\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class Node(ParsedObject):
    """
    class Node {
        pass kw('node')
        name: Opt(Name)
        body: Block(Assign | Config | Function | Handler | State)
    }
    """
    _fields = ('name', 'body')

    def __init__(self, name, body):
        ParsedObject.__init__(self)
        self.name = name
        self.body = body

    def __repr__(self):
        return f'Node(name={self.name!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Node, fullparse)


def _parse_function_120(_ctx, _text, _pos):
    # Begin Str
    value5 = 'node'
    end5 = (_pos + 4)
    if (_text[slice(_pos, end5, None)] == value5):
        _result = value5
        _pos = (yield (3, _ctx._try__ignored, end5))[2]
        _status = True
    else:
        _result = _raise_error120
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_127(_ctx, _text, _pos):
    # Begin Choice
    farthest_err4 = _raise_error127
    backtrack11 = farthest_pos4 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Assign, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack11
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Config, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack11
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Function, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack11
        # Option 4:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Handler, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = backtrack11
        # Option 5:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_State, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos4 < _pos):
            farthest_pos4 = _pos
            farthest_err4 = _result
        _pos = farthest_pos4
        _result = farthest_err4
        break
    # End Choice
    yield (_status, _result, _pos)

def _try_Node(_ctx, _text, _pos):
    # Begin Seq
    start_pos4 = _pos
    while True:
        # Begin Call
        # kw('node')
        arg6 = _wrap_string_literal('node', _parse_function_120)
        func10 = _ParseFunction(_ctx._try_kw, (arg6,), ())
        (_status, _result, _pos) = (yield (3, func10, _pos))
        # End Call
        if not (_status):
            break
        item4 = _result
        # Begin Opt
        # Opt(Name)
        backtrack10 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack10
            _result = None
            _status = True
        # End Opt
        name = _result
        # Begin Call
        # Block(Assign | Config | Function | Handler | State)
        func11 = _ParseFunction(_ctx._try_Block, (_parse_function_127,), ())
        (_status, _result, _pos) = (yield (3, func11, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = Node(name, body)
        _result._metadata.position_info = (start_pos4, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error120(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Node' rule, at the expression:\n"
    "    'node'\n\n"
    "Expected to match the string 'node'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error127(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Node' rule, at the expression:\n"
    '    Assign | Config | Function | Handler | State\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class Template(ParsedObject):
    """
    class Template {
        pass kw('template')
        name: Name
        parameters: ParenthesesList(Parameter)
        returns: Opt(':' >> TypeExpression)
        body: Block(Statement)
    }
    """
    _fields = ('name', 'parameters', 'returns', 'body')

    def __init__(self, name, parameters, returns, body):
        ParsedObject.__init__(self)
        self.name = name
        self.parameters = parameters
        self.returns = returns
        self.body = body

    def __repr__(self):
        return f'Template(name={self.name!r}, parameters={self.parameters!r}, returns={self.returns!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Template, fullparse)


def _parse_function_138(_ctx, _text, _pos):
    # Begin Str
    value6 = 'template'
    end6 = (_pos + 8)
    if (_text[slice(_pos, end6, None)] == value6):
        _result = value6
        _pos = (yield (3, _ctx._try__ignored, end6))[2]
        _status = True
    else:
        _result = _raise_error138
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Template(_ctx, _text, _pos):
    # Begin Seq
    start_pos5 = _pos
    while True:
        # Begin Call
        # kw('template')
        arg7 = _wrap_string_literal('template', _parse_function_138)
        func12 = _ParseFunction(_ctx._try_kw, (arg7,), ())
        (_status, _result, _pos) = (yield (3, func12, _pos))
        # End Call
        if not (_status):
            break
        item5 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
        # End Ref
        if not (_status):
            break
        name = _result
        # Begin Call
        # ParenthesesList(Parameter)
        func13 = _ParseFunction(_ctx._try_ParenthesesList, (_try_Parameter,), ())
        (_status, _result, _pos) = (yield (3, func13, _pos))
        # End Call
        if not (_status):
            break
        parameters = _result
        # Begin Opt
        # Opt(':' >> TypeExpression)
        backtrack12 = _pos
        # Begin Discard
        # ':' >> TypeExpression
        while True:
            # Begin Str
            value7 = ':'
            end7 = (_pos + 1)
            if (_text[slice(_pos, end7, None)] == value7):
                _result = value7
                _pos = (yield (3, _ctx._try__ignored, end7))[2]
                _status = True
            else:
                _result = _raise_error148
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_TypeExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack12
            _result = None
            _status = True
        # End Opt
        returns = _result
        # Begin Call
        # Block(Statement)
        func14 = _ParseFunction(_ctx._try_Block, (_try_Statement,), ())
        (_status, _result, _pos) = (yield (3, func14, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = Template(name, parameters, returns, body)
        _result._metadata.position_info = (start_pos5, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error138(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Template' rule, at the expression:\n"
    "    'template'\n\n"
    "Expected to match the string 'template'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error148(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Template' rule, at the expression:\n"
    "    ':'\n\n"
    "Expected to match the string ':'"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_AnonymousDefinition(_ctx, _text, _pos):
    # Rule 'AnonymousDefinition'
    # Begin Where
    # Definition where `lambda x: x.name is None`
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _ctx._try_Definition, _pos))
    # End Ref
    if _status:
        arg8 = _result
        _result = lambda x: x.name is None
        _status = True
        if _result(arg8):
            _result = arg8
        else:
            _result = _raise_error155
            _status = False
    # End Where
    yield (_status, _result, _pos)

def _parse_AnonymousDefinition(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_AnonymousDefinition, fullparse)

AnonymousDefinition = ParsingRule('AnonymousDefinition', _parse_AnonymousDefinition, """
    AnonymousDefinition = Definition where `lambda x: x.name is None`
""")
def _raise_error155(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'AnonymousDefinition' rule, at the expression:\n"
    '    Definition where `lambda x: x.name is None`\n\n'
    'Expected to satisfy the predicate: `lambda x: x.name is None`'
    )
    raise ParseError((title + details), _pos, line, col)

class Edges(ParsedObject):
    """
    class Edges {
        pass kw('edges')
        body: Block(ConditionalEdges | Edge)
    }
    """
    _fields = ('body',)

    def __init__(self, body):
        ParsedObject.__init__(self)
        self.body = body

    def __repr__(self):
        return f'Edges(body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Edges, fullparse)


def _parse_function_163(_ctx, _text, _pos):
    # Begin Str
    value8 = 'edges'
    end8 = (_pos + 5)
    if (_text[slice(_pos, end8, None)] == value8):
        _result = value8
        _pos = (yield (3, _ctx._try__ignored, end8))[2]
        _status = True
    else:
        _result = _raise_error163
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_167(_ctx, _text, _pos):
    # Begin Choice
    farthest_err5 = _raise_error167
    backtrack13 = farthest_pos5 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ConditionalEdges, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos5 < _pos):
            farthest_pos5 = _pos
            farthest_err5 = _result
        _pos = backtrack13
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Edge, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos5 < _pos):
            farthest_pos5 = _pos
            farthest_err5 = _result
        _pos = farthest_pos5
        _result = farthest_err5
        break
    # End Choice
    yield (_status, _result, _pos)

def _try_Edges(_ctx, _text, _pos):
    # Begin Seq
    start_pos6 = _pos
    while True:
        # Begin Call
        # kw('edges')
        arg9 = _wrap_string_literal('edges', _parse_function_163)
        func15 = _ParseFunction(_ctx._try_kw, (arg9,), ())
        (_status, _result, _pos) = (yield (3, func15, _pos))
        # End Call
        if not (_status):
            break
        item6 = _result
        # Begin Call
        # Block(ConditionalEdges | Edge)
        func16 = _ParseFunction(_ctx._try_Block, (_parse_function_167,), ())
        (_status, _result, _pos) = (yield (3, func16, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = Edges(body)
        _result._metadata.position_info = (start_pos6, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error163(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Edges' rule, at the expression:\n"
    "    'edges'\n\n"
    "Expected to match the string 'edges'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error167(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Edges' rule, at the expression:\n"
    '    ConditionalEdges | Edge\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class ConditionalEdges(ParsedObject):
    """
    class ConditionalEdges {
        pass kw('if')
        condition: ValueExpression
        body: Block(ConditionalEdges | Edge)
    }
    """
    _fields = ('condition', 'body')

    def __init__(self, condition, body):
        ParsedObject.__init__(self)
        self.condition = condition
        self.body = body

    def __repr__(self):
        return f'ConditionalEdges(condition={self.condition!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_ConditionalEdges, fullparse)


def _parse_function_175(_ctx, _text, _pos):
    # Begin Str
    value9 = 'if'
    end9 = (_pos + 2)
    if (_text[slice(_pos, end9, None)] == value9):
        _result = value9
        _pos = (yield (3, _ctx._try__ignored, end9))[2]
        _status = True
    else:
        _result = _raise_error175
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_181(_ctx, _text, _pos):
    # Begin Choice
    farthest_err6 = _raise_error181
    backtrack14 = farthest_pos6 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ConditionalEdges, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos6 < _pos):
            farthest_pos6 = _pos
            farthest_err6 = _result
        _pos = backtrack14
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Edge, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos6 < _pos):
            farthest_pos6 = _pos
            farthest_err6 = _result
        _pos = farthest_pos6
        _result = farthest_err6
        break
    # End Choice
    yield (_status, _result, _pos)

def _try_ConditionalEdges(_ctx, _text, _pos):
    # Begin Seq
    start_pos7 = _pos
    while True:
        # Begin Call
        # kw('if')
        arg10 = _wrap_string_literal('if', _parse_function_175)
        func17 = _ParseFunction(_ctx._try_kw, (arg10,), ())
        (_status, _result, _pos) = (yield (3, func17, _pos))
        # End Call
        if not (_status):
            break
        item7 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        condition = _result
        # Begin Call
        # Block(ConditionalEdges | Edge)
        func18 = _ParseFunction(_ctx._try_Block, (_parse_function_181,), ())
        (_status, _result, _pos) = (yield (3, func18, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = ConditionalEdges(condition, body)
        _result._metadata.position_info = (start_pos7, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error175(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ConditionalEdges' rule, at the expression:\n"
    "    'if'\n\n"
    "Expected to match the string 'if'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error181(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ConditionalEdges' rule, at the expression:\n"
    '    ConditionalEdges | Edge\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class Edge(ParsedObject):
    """
    class Edge {
        nodes: Sep(Word, wrap('>>'), allow_trailer=False, allow_empty=False)
    }
    """
    _fields = ('nodes',)

    def __init__(self, nodes):
        ParsedObject.__init__(self)
        self.nodes = nodes

    def __repr__(self):
        return f'Edge(nodes={self.nodes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Edge, fullparse)


def _parse_function_191(_ctx, _text, _pos):
    # Begin Str
    value10 = '>>'
    end10 = (_pos + 2)
    if (_text[slice(_pos, end10, None)] == value10):
        _result = value10
        _pos = (yield (3, _ctx._try__ignored, end10))[2]
        _status = True
    else:
        _result = _raise_error191
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Edge(_ctx, _text, _pos):
    # Begin Seq
    start_pos8 = _pos
    while True:
        # Begin Sep
        # Sep(Word, wrap('>>'), allow_trailer=False, allow_empty=False)
        staging5 = []
        checkpoint1 = _pos
        while True:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Word, _pos))
            # End Ref
            if not (_status):
                break
            staging5.append(_result)
            checkpoint1 = _pos
            # Begin Call
            # wrap('>>')
            arg11 = _wrap_string_literal('>>', _parse_function_191)
            func19 = _ParseFunction(_ctx._try_wrap, (arg11,), ())
            (_status, _result, _pos) = (yield (3, func19, _pos))
            # End Call
            if not (_status):
                break
        if staging5:
            _result = staging5
            _pos = checkpoint1
            _status = True
        # End Sep
        if not (_status):
            break
        nodes = _result
        _result = Edge(nodes)
        _result._metadata.position_info = (start_pos8, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error191(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Edge' rule, at the expression:\n"
    "    '>>'\n\n"
    "Expected to match the string '>>'"
    )
    raise ParseError((title + details), _pos, line, col)

class Config(ParsedObject):
    """
    class Config {
        pass kw('config')
        name: Opt(Name)
        body: Block(Parameter)
    }
    """
    _fields = ('name', 'body')

    def __init__(self, name, body):
        ParsedObject.__init__(self)
        self.name = name
        self.body = body

    def __repr__(self):
        return f'Config(name={self.name!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Config, fullparse)


def _parse_function_197(_ctx, _text, _pos):
    # Begin Str
    value11 = 'config'
    end11 = (_pos + 6)
    if (_text[slice(_pos, end11, None)] == value11):
        _result = value11
        _pos = (yield (3, _ctx._try__ignored, end11))[2]
        _status = True
    else:
        _result = _raise_error197
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Config(_ctx, _text, _pos):
    # Begin Seq
    start_pos9 = _pos
    while True:
        # Begin Call
        # kw('config')
        arg12 = _wrap_string_literal('config', _parse_function_197)
        func20 = _ParseFunction(_ctx._try_kw, (arg12,), ())
        (_status, _result, _pos) = (yield (3, func20, _pos))
        # End Call
        if not (_status):
            break
        item8 = _result
        # Begin Opt
        # Opt(Name)
        backtrack15 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack15
            _result = None
            _status = True
        # End Opt
        name = _result
        # Begin Call
        # Block(Parameter)
        func21 = _ParseFunction(_ctx._try_Block, (_try_Parameter,), ())
        (_status, _result, _pos) = (yield (3, func21, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = Config(name, body)
        _result._metadata.position_info = (start_pos9, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error197(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Config' rule, at the expression:\n"
    "    'config'\n\n"
    "Expected to match the string 'config'"
    )
    raise ParseError((title + details), _pos, line, col)

class Handler(ParsedObject):
    """
    class Handler {
        pass kw('on')
        action: Word
        parameters: ParenthesesList(Parameter)
        body: Block(Statement)
    }
    """
    _fields = ('action', 'parameters', 'body')

    def __init__(self, action, parameters, body):
        ParsedObject.__init__(self)
        self.action = action
        self.parameters = parameters
        self.body = body

    def __repr__(self):
        return f'Handler(action={self.action!r}, parameters={self.parameters!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Handler, fullparse)


def _parse_function_210(_ctx, _text, _pos):
    # Begin Str
    value12 = 'on'
    end12 = (_pos + 2)
    if (_text[slice(_pos, end12, None)] == value12):
        _result = value12
        _pos = (yield (3, _ctx._try__ignored, end12))[2]
        _status = True
    else:
        _result = _raise_error210
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Handler(_ctx, _text, _pos):
    # Begin Seq
    start_pos10 = _pos
    while True:
        # Begin Call
        # kw('on')
        arg13 = _wrap_string_literal('on', _parse_function_210)
        func22 = _ParseFunction(_ctx._try_kw, (arg13,), ())
        (_status, _result, _pos) = (yield (3, func22, _pos))
        # End Call
        if not (_status):
            break
        item9 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Word, _pos))
        # End Ref
        if not (_status):
            break
        action = _result
        # Begin Call
        # ParenthesesList(Parameter)
        func23 = _ParseFunction(_ctx._try_ParenthesesList, (_try_Parameter,), ())
        (_status, _result, _pos) = (yield (3, func23, _pos))
        # End Call
        if not (_status):
            break
        parameters = _result
        # Begin Call
        # Block(Statement)
        func24 = _ParseFunction(_ctx._try_Block, (_try_Statement,), ())
        (_status, _result, _pos) = (yield (3, func24, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = Handler(action, parameters, body)
        _result._metadata.position_info = (start_pos10, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error210(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Handler' rule, at the expression:\n"
    "    'on'\n\n"
    "Expected to match the string 'on'"
    )
    raise ParseError((title + details), _pos, line, col)

class State(ParsedObject):
    """
    class State {
        pass kw('state')
        name: Opt(Name)
        body: Block(Parameter)
    }
    """
    _fields = ('name', 'body')

    def __init__(self, name, body):
        ParsedObject.__init__(self)
        self.name = name
        self.body = body

    def __repr__(self):
        return f'State(name={self.name!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_State, fullparse)


def _parse_function_226(_ctx, _text, _pos):
    # Begin Str
    value13 = 'state'
    end13 = (_pos + 5)
    if (_text[slice(_pos, end13, None)] == value13):
        _result = value13
        _pos = (yield (3, _ctx._try__ignored, end13))[2]
        _status = True
    else:
        _result = _raise_error226
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_State(_ctx, _text, _pos):
    # Begin Seq
    start_pos11 = _pos
    while True:
        # Begin Call
        # kw('state')
        arg14 = _wrap_string_literal('state', _parse_function_226)
        func25 = _ParseFunction(_ctx._try_kw, (arg14,), ())
        (_status, _result, _pos) = (yield (3, func25, _pos))
        # End Call
        if not (_status):
            break
        item10 = _result
        # Begin Opt
        # Opt(Name)
        backtrack16 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack16
            _result = None
            _status = True
        # End Opt
        name = _result
        # Begin Call
        # Block(Parameter)
        func26 = _ParseFunction(_ctx._try_Block, (_try_Parameter,), ())
        (_status, _result, _pos) = (yield (3, func26, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = State(name, body)
        _result._metadata.position_info = (start_pos11, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error226(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'State' rule, at the expression:\n"
    "    'state'\n\n"
    "Expected to match the string 'state'"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Statement(_ctx, _text, _pos):
    # Rule 'Statement'
    # Begin Choice
    farthest_err7 = _raise_error235
    backtrack17 = farthest_pos7 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Assign, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos7 < _pos):
            farthest_pos7 = _pos
            farthest_err7 = _result
        _pos = backtrack17
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Emit, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos7 < _pos):
            farthest_pos7 = _pos
            farthest_err7 = _result
        _pos = backtrack17
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_For, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos7 < _pos):
            farthest_pos7 = _pos
            farthest_err7 = _result
        _pos = backtrack17
        # Option 4:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Operate, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos7 < _pos):
            farthest_pos7 = _pos
            farthest_err7 = _result
        _pos = backtrack17
        # Option 5:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Return, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos7 < _pos):
            farthest_pos7 = _pos
            farthest_err7 = _result
        _pos = backtrack17
        # Option 6:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos7 < _pos):
            farthest_pos7 = _pos
            farthest_err7 = _result
        _pos = farthest_pos7
        _result = farthest_err7
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_Statement(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Statement, fullparse)

Statement = ParsingRule('Statement', _parse_Statement, """
    Statement = Assign | Emit | For | Operate | Return | ValueExpression
""")
def _raise_error235(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Statement' rule, at the expression:\n"
    '    Assign | Emit | For | Operate | Return | ValueExpression\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class Assign(ParsedObject):
    """
    class Assign {
        storage: ValueExpression | Names
        operator: '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '^=' | '|='
        value: AnonymousDefinition | ValueExpression
    }
    """
    _fields = ('storage', 'operator', 'value')

    def __init__(self, storage, operator, value):
        ParsedObject.__init__(self)
        self.storage = storage
        self.operator = operator
        self.value = value

    def __repr__(self):
        return f'Assign(storage={self.storage!r}, operator={self.operator!r}, value={self.value!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Assign, fullparse)


def _try_Assign(_ctx, _text, _pos):
    # Begin Seq
    start_pos12 = _pos
    while True:
        # Begin Choice
        farthest_err8 = _raise_error245
        backtrack18 = farthest_pos8 = _pos
        while True:
            # Option 1:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos8 < _pos):
                farthest_pos8 = _pos
                farthest_err8 = _result
            _pos = backtrack18
            # Option 2:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Names, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos8 < _pos):
                farthest_pos8 = _pos
                farthest_err8 = _result
            _pos = farthest_pos8
            _result = farthest_err8
            break
        # End Choice
        if not (_status):
            break
        storage = _result
        # Begin Choice
        farthest_err9 = _raise_error249
        farthest_pos9 = _pos
        while True:
            # Option 1:
            # Begin Str
            value14 = '='
            end14 = (_pos + 1)
            if (_text[slice(_pos, end14, None)] == value14):
                _result = value14
                _pos = (yield (3, _ctx._try__ignored, end14))[2]
                _status = True
            else:
                _result = _raise_error250
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Str
            value15 = '+='
            end15 = (_pos + 2)
            if (_text[slice(_pos, end15, None)] == value15):
                _result = value15
                _pos = (yield (3, _ctx._try__ignored, end15))[2]
                _status = True
            else:
                _result = _raise_error251
                _status = False
            # End Str
            if _status:
                break
            # Option 3:
            # Begin Str
            value16 = '-='
            end16 = (_pos + 2)
            if (_text[slice(_pos, end16, None)] == value16):
                _result = value16
                _pos = (yield (3, _ctx._try__ignored, end16))[2]
                _status = True
            else:
                _result = _raise_error252
                _status = False
            # End Str
            if _status:
                break
            # Option 4:
            # Begin Str
            value17 = '*='
            end17 = (_pos + 2)
            if (_text[slice(_pos, end17, None)] == value17):
                _result = value17
                _pos = (yield (3, _ctx._try__ignored, end17))[2]
                _status = True
            else:
                _result = _raise_error253
                _status = False
            # End Str
            if _status:
                break
            # Option 5:
            # Begin Str
            value18 = '/='
            end18 = (_pos + 2)
            if (_text[slice(_pos, end18, None)] == value18):
                _result = value18
                _pos = (yield (3, _ctx._try__ignored, end18))[2]
                _status = True
            else:
                _result = _raise_error254
                _status = False
            # End Str
            if _status:
                break
            # Option 6:
            # Begin Str
            value19 = '%='
            end19 = (_pos + 2)
            if (_text[slice(_pos, end19, None)] == value19):
                _result = value19
                _pos = (yield (3, _ctx._try__ignored, end19))[2]
                _status = True
            else:
                _result = _raise_error255
                _status = False
            # End Str
            if _status:
                break
            # Option 7:
            # Begin Str
            value20 = '<<='
            end20 = (_pos + 3)
            if (_text[slice(_pos, end20, None)] == value20):
                _result = value20
                _pos = (yield (3, _ctx._try__ignored, end20))[2]
                _status = True
            else:
                _result = _raise_error256
                _status = False
            # End Str
            if _status:
                break
            # Option 8:
            # Begin Str
            value21 = '>>='
            end21 = (_pos + 3)
            if (_text[slice(_pos, end21, None)] == value21):
                _result = value21
                _pos = (yield (3, _ctx._try__ignored, end21))[2]
                _status = True
            else:
                _result = _raise_error257
                _status = False
            # End Str
            if _status:
                break
            # Option 9:
            # Begin Str
            value22 = '&='
            end22 = (_pos + 2)
            if (_text[slice(_pos, end22, None)] == value22):
                _result = value22
                _pos = (yield (3, _ctx._try__ignored, end22))[2]
                _status = True
            else:
                _result = _raise_error258
                _status = False
            # End Str
            if _status:
                break
            # Option 10:
            # Begin Str
            value23 = '^='
            end23 = (_pos + 2)
            if (_text[slice(_pos, end23, None)] == value23):
                _result = value23
                _pos = (yield (3, _ctx._try__ignored, end23))[2]
                _status = True
            else:
                _result = _raise_error259
                _status = False
            # End Str
            if _status:
                break
            # Option 11:
            # Begin Str
            value24 = '|='
            end24 = (_pos + 2)
            if (_text[slice(_pos, end24, None)] == value24):
                _result = value24
                _pos = (yield (3, _ctx._try__ignored, end24))[2]
                _status = True
            else:
                _result = _raise_error260
                _status = False
            # End Str
            if _status:
                break
            _pos = farthest_pos9
            _result = farthest_err9
            break
        # End Choice
        if not (_status):
            break
        operator = _result
        # Begin Choice
        farthest_err10 = _raise_error262
        backtrack19 = farthest_pos10 = _pos
        while True:
            # Option 1:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_AnonymousDefinition, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos10 < _pos):
                farthest_pos10 = _pos
                farthest_err10 = _result
            _pos = backtrack19
            # Option 2:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos10 < _pos):
                farthest_pos10 = _pos
                farthest_err10 = _result
            _pos = farthest_pos10
            _result = farthest_err10
            break
        # End Choice
        if not (_status):
            break
        value = _result
        _result = Assign(storage, operator, value)
        _result._metadata.position_info = (start_pos12, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error245(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    '    ValueExpression | Names\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error249(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '=' | '+=' | '-=' | '*=' | '/=' | '%=' | '<<=' | '>>=' | '&=' | '^=' | '|='\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error250(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '='\n\n"
    "Expected to match the string '='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error251(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '+='\n\n"
    "Expected to match the string '+='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error252(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '-='\n\n"
    "Expected to match the string '-='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error253(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '*='\n\n"
    "Expected to match the string '*='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error254(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '/='\n\n"
    "Expected to match the string '/='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error255(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '%='\n\n"
    "Expected to match the string '%='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error256(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '<<='\n\n"
    "Expected to match the string '<<='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error257(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '>>='\n\n"
    "Expected to match the string '>>='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error258(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '&='\n\n"
    "Expected to match the string '&='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error259(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '^='\n\n"
    "Expected to match the string '^='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error260(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    "    '|='\n\n"
    "Expected to match the string '|='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error262(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Assign' rule, at the expression:\n"
    '    AnonymousDefinition | ValueExpression\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class Emit(ParsedObject):
    """
    class Emit {
        pass Opt('emit')
        key: ValueExpression
        target: Opt('to' >> ValueExpression)
    }
    """
    _fields = ('key', 'target')

    def __init__(self, key, target):
        ParsedObject.__init__(self)
        self.key = key
        self.target = target

    def __repr__(self):
        return f'Emit(key={self.key!r}, target={self.target!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Emit, fullparse)


def _try_Emit(_ctx, _text, _pos):
    # Begin Seq
    start_pos13 = _pos
    while True:
        # Begin Opt
        # Opt('emit')
        backtrack20 = _pos
        # Begin Str
        value25 = 'emit'
        end25 = (_pos + 4)
        if (_text[slice(_pos, end25, None)] == value25):
            _result = value25
            _pos = (yield (3, _ctx._try__ignored, end25))[2]
            _status = True
        else:
            _result = _raise_error269
            _status = False
        # End Str
        if not (_status):
            _pos = backtrack20
            _result = None
            _status = True
        # End Opt
        item11 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        key = _result
        # Begin Opt
        # Opt('to' >> ValueExpression)
        backtrack21 = _pos
        # Begin Discard
        # 'to' >> ValueExpression
        while True:
            # Begin Str
            value26 = 'to'
            end26 = (_pos + 2)
            if (_text[slice(_pos, end26, None)] == value26):
                _result = value26
                _pos = (yield (3, _ctx._try__ignored, end26))[2]
                _status = True
            else:
                _result = _raise_error275
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack21
            _result = None
            _status = True
        # End Opt
        target = _result
        _result = Emit(key, target)
        _result._metadata.position_info = (start_pos13, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error269(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Emit' rule, at the expression:\n"
    "    'emit'\n\n"
    "Expected to match the string 'emit'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error275(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Emit' rule, at the expression:\n"
    "    'to'\n\n"
    "Expected to match the string 'to'"
    )
    raise ParseError((title + details), _pos, line, col)

class For(ParsedObject):
    """
    class For {
        pass kw('for')
        names: Names
        pass kw('in')
        source: ValueExpression
        guard: Opt((Pad >> kw('if')) >> ValueExpression)
        body: Block(Statement)
    }
    """
    _fields = ('names', 'source', 'guard', 'body')

    def __init__(self, names, source, guard, body):
        ParsedObject.__init__(self)
        self.names = names
        self.source = source
        self.guard = guard
        self.body = body

    def __repr__(self):
        return f'For(names={self.names!r}, source={self.source!r}, guard={self.guard!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_For, fullparse)


def _parse_function_282(_ctx, _text, _pos):
    # Begin Str
    value27 = 'for'
    end27 = (_pos + 3)
    if (_text[slice(_pos, end27, None)] == value27):
        _result = value27
        _pos = (yield (3, _ctx._try__ignored, end27))[2]
        _status = True
    else:
        _result = _raise_error282
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_288(_ctx, _text, _pos):
    # Begin Str
    value28 = 'in'
    end28 = (_pos + 2)
    if (_text[slice(_pos, end28, None)] == value28):
        _result = value28
        _pos = (yield (3, _ctx._try__ignored, end28))[2]
        _status = True
    else:
        _result = _raise_error288
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_298(_ctx, _text, _pos):
    # Begin Str
    value29 = 'if'
    end29 = (_pos + 2)
    if (_text[slice(_pos, end29, None)] == value29):
        _result = value29
        _pos = (yield (3, _ctx._try__ignored, end29))[2]
        _status = True
    else:
        _result = _raise_error298
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_For(_ctx, _text, _pos):
    # Begin Seq
    start_pos14 = _pos
    while True:
        # Begin Call
        # kw('for')
        arg15 = _wrap_string_literal('for', _parse_function_282)
        func27 = _ParseFunction(_ctx._try_kw, (arg15,), ())
        (_status, _result, _pos) = (yield (3, func27, _pos))
        # End Call
        if not (_status):
            break
        item12 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Names, _pos))
        # End Ref
        if not (_status):
            break
        names = _result
        # Begin Call
        # kw('in')
        arg16 = _wrap_string_literal('in', _parse_function_288)
        func28 = _ParseFunction(_ctx._try_kw, (arg16,), ())
        (_status, _result, _pos) = (yield (3, func28, _pos))
        # End Call
        if not (_status):
            break
        item13 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        source = _result
        # Begin Opt
        # Opt((Pad >> kw('if')) >> ValueExpression)
        backtrack22 = _pos
        # Begin Discard
        # (Pad >> kw('if')) >> ValueExpression
        while True:
            # Begin Discard
            # Pad >> kw('if')
            while True:
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                # End Ref
                if not (_status):
                    break
                # Begin Call
                # kw('if')
                arg17 = _wrap_string_literal('if', _parse_function_298)
                func29 = _ParseFunction(_ctx._try_kw, (arg17,), ())
                (_status, _result, _pos) = (yield (3, func29, _pos))
                # End Call
                break
            # End Discard
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack22
            _result = None
            _status = True
        # End Opt
        guard = _result
        # Begin Call
        # Block(Statement)
        func30 = _ParseFunction(_ctx._try_Block, (_try_Statement,), ())
        (_status, _result, _pos) = (yield (3, func30, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = For(names, source, guard, body)
        _result._metadata.position_info = (start_pos14, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error282(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'For' rule, at the expression:\n"
    "    'for'\n\n"
    "Expected to match the string 'for'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error288(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'For' rule, at the expression:\n"
    "    'in'\n\n"
    "Expected to match the string 'in'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error298(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'For' rule, at the expression:\n"
    "    'if'\n\n"
    "Expected to match the string 'if'"
    )
    raise ParseError((title + details), _pos, line, col)

class Operate(ParsedObject):
    """
    class Operate {
        action: 'press' | 'release'
        key: ValueExpression
        target: Opt('to' >> ValueExpression)
    }
    """
    _fields = ('action', 'key', 'target')

    def __init__(self, action, key, target):
        ParsedObject.__init__(self)
        self.action = action
        self.key = key
        self.target = target

    def __repr__(self):
        return f'Operate(action={self.action!r}, key={self.key!r}, target={self.target!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Operate, fullparse)


def _try_Operate(_ctx, _text, _pos):
    # Begin Seq
    start_pos15 = _pos
    while True:
        # Begin Choice
        farthest_err11 = _raise_error307
        farthest_pos11 = _pos
        while True:
            # Option 1:
            # Begin Str
            value30 = 'press'
            end30 = (_pos + 5)
            if (_text[slice(_pos, end30, None)] == value30):
                _result = value30
                _pos = (yield (3, _ctx._try__ignored, end30))[2]
                _status = True
            else:
                _result = _raise_error308
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Str
            value31 = 'release'
            end31 = (_pos + 7)
            if (_text[slice(_pos, end31, None)] == value31):
                _result = value31
                _pos = (yield (3, _ctx._try__ignored, end31))[2]
                _status = True
            else:
                _result = _raise_error309
                _status = False
            # End Str
            if _status:
                break
            _pos = farthest_pos11
            _result = farthest_err11
            break
        # End Choice
        if not (_status):
            break
        action = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        key = _result
        # Begin Opt
        # Opt('to' >> ValueExpression)
        backtrack23 = _pos
        # Begin Discard
        # 'to' >> ValueExpression
        while True:
            # Begin Str
            value32 = 'to'
            end32 = (_pos + 2)
            if (_text[slice(_pos, end32, None)] == value32):
                _result = value32
                _pos = (yield (3, _ctx._try__ignored, end32))[2]
                _status = True
            else:
                _result = _raise_error315
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack23
            _result = None
            _status = True
        # End Opt
        target = _result
        _result = Operate(action, key, target)
        _result._metadata.position_info = (start_pos15, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error307(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Operate' rule, at the expression:\n"
    "    'press' | 'release'\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error308(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Operate' rule, at the expression:\n"
    "    'press'\n\n"
    "Expected to match the string 'press'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error309(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Operate' rule, at the expression:\n"
    "    'release'\n\n"
    "Expected to match the string 'release'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error315(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Operate' rule, at the expression:\n"
    "    'to'\n\n"
    "Expected to match the string 'to'"
    )
    raise ParseError((title + details), _pos, line, col)

class Return(ParsedObject):
    """
    class Return {
        pass kw('return')
        value: Opt(ValueExpression)
    }
    """
    _fields = ('value',)

    def __init__(self, value):
        ParsedObject.__init__(self)
        self.value = value

    def __repr__(self):
        return f'Return(value={self.value!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Return, fullparse)


def _parse_function_322(_ctx, _text, _pos):
    # Begin Str
    value33 = 'return'
    end33 = (_pos + 6)
    if (_text[slice(_pos, end33, None)] == value33):
        _result = value33
        _pos = (yield (3, _ctx._try__ignored, end33))[2]
        _status = True
    else:
        _result = _raise_error322
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Return(_ctx, _text, _pos):
    # Begin Seq
    start_pos16 = _pos
    while True:
        # Begin Call
        # kw('return')
        arg18 = _wrap_string_literal('return', _parse_function_322)
        func31 = _ParseFunction(_ctx._try_kw, (arg18,), ())
        (_status, _result, _pos) = (yield (3, func31, _pos))
        # End Call
        if not (_status):
            break
        item14 = _result
        # Begin Opt
        # Opt(ValueExpression)
        backtrack24 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            _pos = backtrack24
            _result = None
            _status = True
        # End Opt
        value = _result
        _result = Return(value)
        _result._metadata.position_info = (start_pos16, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error322(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Return' rule, at the expression:\n"
    "    'return'\n\n"
    "Expected to match the string 'return'"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_TypeExpression(_ctx, _text, _pos):
    # Rule 'TypeExpression'
    # Begin Ref
    (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
    # End Ref
    yield (_status, _result, _pos)

def _parse_TypeExpression(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_TypeExpression, fullparse)

TypeExpression = ParsingRule('TypeExpression', _parse_TypeExpression, """
    TypeExpression = ValueExpression
""")
def _parse_function_337(_ctx, _text, _pos):
    # Begin Str
    value35 = 'not'
    end35 = (_pos + 3)
    if (_text[slice(_pos, end35, None)] == value35):
        _result = value35
        _pos = (yield (3, _ctx._try__ignored, end35))[2]
        _status = True
    else:
        _result = _raise_error337
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_376(_ctx, _text, _pos):
    # Begin Str
    value43 = '<<'
    end43 = (_pos + 2)
    if (_text[slice(_pos, end43, None)] == value43):
        _result = value43
        _pos = (yield (3, _ctx._try__ignored, end43))[2]
        _status = True
    else:
        _result = _raise_error376
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_379(_ctx, _text, _pos):
    # Begin Str
    value44 = '>>'
    end44 = (_pos + 2)
    if (_text[slice(_pos, end44, None)] == value44):
        _result = value44
        _pos = (yield (3, _ctx._try__ignored, end44))[2]
        _status = True
    else:
        _result = _raise_error379
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_387(_ctx, _text, _pos):
    # Begin Choice
    farthest_err19 = _raise_error387
    farthest_pos19 = _pos
    while True:
        # Option 1:
        # Begin Str
        value47 = '<'
        end47 = (_pos + 1)
        if (_text[slice(_pos, end47, None)] == value47):
            _result = value47
            _pos = (yield (3, _ctx._try__ignored, end47))[2]
            _status = True
        else:
            _result = _raise_error388
            _status = False
        # End Str
        if _status:
            break
        # Option 2:
        # Begin Str
        value48 = '>'
        end48 = (_pos + 1)
        if (_text[slice(_pos, end48, None)] == value48):
            _result = value48
            _pos = (yield (3, _ctx._try__ignored, end48))[2]
            _status = True
        else:
            _result = _raise_error389
            _status = False
        # End Str
        if _status:
            break
        _pos = farthest_pos19
        _result = farthest_err19
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_function_410(_ctx, _text, _pos):
    # Begin Str
    value54 = '|'
    end54 = (_pos + 1)
    if (_text[slice(_pos, end54, None)] == value54):
        _result = value54
        _pos = (yield (3, _ctx._try__ignored, end54))[2]
        _status = True
    else:
        _result = _raise_error410
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_417(_ctx, _text, _pos):
    # Begin Str
    value55 = 'and'
    end55 = (_pos + 3)
    if (_text[slice(_pos, end55, None)] == value55):
        _result = value55
        _pos = (yield (3, _ctx._try__ignored, end55))[2]
        _status = True
    else:
        _result = _raise_error417
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_415(_ctx, _text, _pos):
    # Begin Call
    # kw('and')
    arg35 = _wrap_string_literal('and', _parse_function_417)
    func38 = _ParseFunction(_ctx._try_kw, (arg35,), ())
    (_status, _result, _pos) = (yield (3, func38, _pos))
    # End Call
    yield (_status, _result, _pos)

def _parse_function_424(_ctx, _text, _pos):
    # Begin Str
    value56 = 'or'
    end56 = (_pos + 2)
    if (_text[slice(_pos, end56, None)] == value56):
        _result = value56
        _pos = (yield (3, _ctx._try__ignored, end56))[2]
        _status = True
    else:
        _result = _raise_error424
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_422(_ctx, _text, _pos):
    # Begin Call
    # kw('or')
    arg37 = _wrap_string_literal('or', _parse_function_424)
    func40 = _ParseFunction(_ctx._try_kw, (arg37,), ())
    (_status, _result, _pos) = (yield (3, func40, _pos))
    # End Call
    yield (_status, _result, _pos)

def _try_ValueExpression(_ctx, _text, _pos):
    # Rule 'ValueExpression'
    # Begin OperatorTable
    # Name | LiteralExpression with operators {
    #     mixfix: ('(' >> wrap(ValueExpression)) << ')'
    #     postfix: ArgumentList, ElementAccess, FieldAccess, GenericArgumentList
    #     prefix: '-'
    #     left: '*', '/', '%'
    #     left: '+', '-'
    #     infix: wrap('<<'), wrap('>>')
    #     infix: '<=', '>=', RequiredSpace('<' | '>')
    #     infix: 'in', NotIn
    #     infix: '==', '!='
    #     left: '&'
    #     left: '^'
    #     left: wrap('|')
    #     prefix: kw('not')
    #     left: wrap(kw('and'))
    #     left: wrap(kw('or'))
    #     mixfix: If, Match
    # }
    _outer_checkpoint1 = _pos
    _operand_stack1 = []
    _operator_stack1 = []
    _operator_marker1 = 0
    while True:
        while True:
            _inner_checkpoint1 = _pos
            # Begin Longest
            has_result1 = False
            farthest_error_result1 = _raise_error330
            farthest_error_position1 = _raise_error330
            backtrack25 = farthest_position1 = farthest_error_position1 = _pos
            # Option 1:
            # Begin Apply
            # '-' |> `lambda x: (2, 0, x)`
            # Begin Str
            value34 = '-'
            end34 = (_pos + 1)
            if (_text[slice(_pos, end34, None)] == value34):
                _result = value34
                _pos = (yield (3, _ctx._try__ignored, end34))[2]
                _status = True
            else:
                _result = _raise_error332
                _status = False
            # End Str
            if _status:
                arg19 = _result
                _result = lambda x: (2, 0, x)
                _status = True
                _result = _result(arg19)
            # End Apply
            if _status:
                farthest_result1 = _result
                farthest_position1 = _pos
                has_result1 = True
            elif not has_result1 and ((farthest_error_position1 < _pos)):
                farthest_error_position1 = _pos
                farthest_error_result1 = _result
            _pos = backtrack25
            # Option 2:
            # Begin Apply
            # kw('not') |> `lambda x: (12, 0, x)`
            # Begin Call
            # kw('not')
            arg20 = _wrap_string_literal('not', _parse_function_337)
            func32 = _ParseFunction(_ctx._try_kw, (arg20,), ())
            (_status, _result, _pos) = (yield (3, func32, _pos))
            # End Call
            if _status:
                arg21 = _result
                _result = lambda x: (12, 0, x)
                _status = True
                _result = _result(arg21)
            # End Apply
            if _status:
                if not (has_result1):
                    farthest_result1 = _result
                    farthest_position1 = _pos
                    has_result1 = True
                elif (farthest_position1 < _pos):
                    farthest_result1 = _result
                    farthest_position1 = _pos
            elif not has_result1 and ((farthest_error_position1 < _pos)):
                farthest_error_position1 = _pos
                farthest_error_result1 = _result
            if has_result1:
                _result = farthest_result1
                _pos = farthest_position1
                _status = True
            else:
                _result = farthest_error_result1
                _pos = farthest_error_position1
            # End Longest
            if not (_status):
                _pos = _inner_checkpoint1
                break
            _operator_stack1.append(_result)
        _inner_checkpoint1 = _pos
        # Begin Longest
        has_result2 = False
        farthest_error_result2 = _raise_error339
        farthest_error_position2 = _raise_error339
        backtrack26 = farthest_position2 = farthest_error_position2 = _pos
        # Option 1:
        # Begin Choice
        farthest_err12 = _raise_error340
        backtrack27 = farthest_pos12 = _pos
        while True:
            # Option 1:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos12 < _pos):
                farthest_pos12 = _pos
                farthest_err12 = _result
            _pos = backtrack27
            # Option 2:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_LiteralExpression, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos12 < _pos):
                farthest_pos12 = _pos
                farthest_err12 = _result
            _pos = farthest_pos12
            _result = farthest_err12
            break
        # End Choice
        if _status:
            farthest_result2 = _result
            farthest_position2 = _pos
            has_result2 = True
        elif not has_result2 and ((farthest_error_position2 < _pos)):
            farthest_error_position2 = _pos
            farthest_error_result2 = _result
        _pos = backtrack26
        # Option 2:
        # Begin Discard
        # ('(' >> wrap(ValueExpression)) << ')'
        while True:
            # Begin Discard
            # '(' >> wrap(ValueExpression)
            while True:
                # Begin Str
                value36 = '('
                end36 = (_pos + 1)
                if (_text[slice(_pos, end36, None)] == value36):
                    _result = value36
                    _pos = (yield (3, _ctx._try__ignored, end36))[2]
                    _status = True
                else:
                    _result = _raise_error345
                    _status = False
                # End Str
                if not (_status):
                    break
                # Begin Call
                # wrap(ValueExpression)
                func33 = _ParseFunction(_ctx._try_wrap, (_try_ValueExpression,), ())
                (_status, _result, _pos) = (yield (3, func33, _pos))
                # End Call
                break
            # End Discard
            if not (_status):
                break
            staging6 = _result
            # Begin Str
            value37 = ')'
            end37 = (_pos + 1)
            if (_text[slice(_pos, end37, None)] == value37):
                _result = value37
                _pos = (yield (3, _ctx._try__ignored, end37))[2]
                _status = True
            else:
                _result = _raise_error349
                _status = False
            # End Str
            if _status:
                _result = staging6
            break
        # End Discard
        if _status:
            if not (has_result2):
                farthest_result2 = _result
                farthest_position2 = _pos
                has_result2 = True
            elif (farthest_position2 < _pos):
                farthest_result2 = _result
                farthest_position2 = _pos
        elif not has_result2 and ((farthest_error_position2 < _pos)):
            farthest_error_position2 = _pos
            farthest_error_result2 = _result
        _pos = backtrack26
        # Option 3:
        # Begin Choice
        farthest_err13 = _raise_error350
        backtrack28 = farthest_pos13 = _pos
        while True:
            # Option 1:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_If, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos13 < _pos):
                farthest_pos13 = _pos
                farthest_err13 = _result
            _pos = backtrack28
            # Option 2:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Match, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos13 < _pos):
                farthest_pos13 = _pos
                farthest_err13 = _result
            _pos = farthest_pos13
            _result = farthest_err13
            break
        # End Choice
        if _status:
            if not (has_result2):
                farthest_result2 = _result
                farthest_position2 = _pos
                has_result2 = True
            elif (farthest_position2 < _pos):
                farthest_result2 = _result
                farthest_position2 = _pos
        elif not has_result2 and ((farthest_error_position2 < _pos)):
            farthest_error_position2 = _pos
            farthest_error_result2 = _result
        if has_result2:
            _result = farthest_result2
            _pos = farthest_position2
            _status = True
        else:
            _result = farthest_error_result2
            _pos = farthest_error_position2
        # End Longest
        if not (_status):
            if _operand_stack1:
                _pos = _outer_checkpoint1
            break
        _operand_stack1.append(_result)
        while True:
            _inner_checkpoint1 = _pos
            # Begin Apply
            # (ArgumentList | ElementAccess | FieldAccess | GenericArgumentList) |> `lambda x: (1, x)`
            # Begin Choice
            farthest_err14 = _raise_error354
            backtrack29 = farthest_pos14 = _pos
            while True:
                # Option 1:
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _ctx._try_ArgumentList, _pos))
                # End Ref
                if _status:
                    break
                if (farthest_pos14 < _pos):
                    farthest_pos14 = _pos
                    farthest_err14 = _result
                _pos = backtrack29
                # Option 2:
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _ctx._try_ElementAccess, _pos))
                # End Ref
                if _status:
                    break
                if (farthest_pos14 < _pos):
                    farthest_pos14 = _pos
                    farthest_err14 = _result
                _pos = backtrack29
                # Option 3:
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _ctx._try_FieldAccess, _pos))
                # End Ref
                if _status:
                    break
                if (farthest_pos14 < _pos):
                    farthest_pos14 = _pos
                    farthest_err14 = _result
                _pos = backtrack29
                # Option 4:
                # Begin Ref
                (_status, _result, _pos) = (yield (3, _ctx._try_GenericArgumentList, _pos))
                # End Ref
                if _status:
                    break
                if (farthest_pos14 < _pos):
                    farthest_pos14 = _pos
                    farthest_err14 = _result
                _pos = farthest_pos14
                _result = farthest_err14
                break
            # End Choice
            if _status:
                arg22 = _result
                _result = lambda x: (1, x)
                _status = True
                _result = _result(arg22)
            # End Apply
            if not (_status):
                _pos = _inner_checkpoint1
                break
            while _operator_stack1 and _operator_stack1[-1][0] < _result[0]:
                _, _is_infix, _operator = _operator_stack1.pop()
                _right = _operand_stack1.pop()
                if _is_infix:
                    _left = _operand_stack1.pop()
                    _operand_stack1.append(Infix(_left, _operator, _right))
                else:
                    _operand_stack1.append(Prefix(_operator, _right))
            _operand = _operand_stack1.pop()
            _operand_stack1.append(Postfix(_operand, _result[1]))
        _operator_marker1 = len(_operator_stack1)
        _outer_checkpoint1 = _pos
        # Begin Longest
        has_result3 = False
        farthest_error_result3 = _raise_error360
        farthest_error_position3 = _raise_error360
        backtrack30 = farthest_position3 = farthest_error_position3 = _pos
        # Option 1:
        # Begin Apply
        # ('*' | '/' | '%') |> `lambda x: (3, 1, x)`
        # Begin Choice
        farthest_err15 = _raise_error362
        farthest_pos15 = _pos
        while True:
            # Option 1:
            # Begin Str
            value38 = '*'
            end38 = (_pos + 1)
            if (_text[slice(_pos, end38, None)] == value38):
                _result = value38
                _pos = (yield (3, _ctx._try__ignored, end38))[2]
                _status = True
            else:
                _result = _raise_error363
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Str
            value39 = '/'
            end39 = (_pos + 1)
            if (_text[slice(_pos, end39, None)] == value39):
                _result = value39
                _pos = (yield (3, _ctx._try__ignored, end39))[2]
                _status = True
            else:
                _result = _raise_error364
                _status = False
            # End Str
            if _status:
                break
            # Option 3:
            # Begin Str
            value40 = '%'
            end40 = (_pos + 1)
            if (_text[slice(_pos, end40, None)] == value40):
                _result = value40
                _pos = (yield (3, _ctx._try__ignored, end40))[2]
                _status = True
            else:
                _result = _raise_error365
                _status = False
            # End Str
            if _status:
                break
            _pos = farthest_pos15
            _result = farthest_err15
            break
        # End Choice
        if _status:
            arg23 = _result
            _result = lambda x: (3, 1, x)
            _status = True
            _result = _result(arg23)
        # End Apply
        if _status:
            farthest_result3 = _result
            farthest_position3 = _pos
            has_result3 = True
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack30
        # Option 2:
        # Begin Apply
        # ('+' | '-') |> `lambda x: (4, 1, x)`
        # Begin Choice
        farthest_err16 = _raise_error368
        farthest_pos16 = _pos
        while True:
            # Option 1:
            # Begin Str
            value41 = '+'
            end41 = (_pos + 1)
            if (_text[slice(_pos, end41, None)] == value41):
                _result = value41
                _pos = (yield (3, _ctx._try__ignored, end41))[2]
                _status = True
            else:
                _result = _raise_error369
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Str
            value42 = '-'
            end42 = (_pos + 1)
            if (_text[slice(_pos, end42, None)] == value42):
                _result = value42
                _pos = (yield (3, _ctx._try__ignored, end42))[2]
                _status = True
            else:
                _result = _raise_error370
                _status = False
            # End Str
            if _status:
                break
            _pos = farthest_pos16
            _result = farthest_err16
            break
        # End Choice
        if _status:
            arg24 = _result
            _result = lambda x: (4, 1, x)
            _status = True
            _result = _result(arg24)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack30
        # Option 3:
        # Begin Apply
        # (wrap('<<') | wrap('>>')) |> `lambda x: (5, 3, x)`
        # Begin Choice
        farthest_err17 = _raise_error373
        backtrack31 = farthest_pos17 = _pos
        while True:
            # Option 1:
            # Begin Call
            # wrap('<<')
            arg25 = _wrap_string_literal('<<', _parse_function_376)
            func34 = _ParseFunction(_ctx._try_wrap, (arg25,), ())
            (_status, _result, _pos) = (yield (3, func34, _pos))
            # End Call
            if _status:
                break
            if (farthest_pos17 < _pos):
                farthest_pos17 = _pos
                farthest_err17 = _result
            _pos = backtrack31
            # Option 2:
            # Begin Call
            # wrap('>>')
            arg26 = _wrap_string_literal('>>', _parse_function_379)
            func35 = _ParseFunction(_ctx._try_wrap, (arg26,), ())
            (_status, _result, _pos) = (yield (3, func35, _pos))
            # End Call
            if _status:
                break
            if (farthest_pos17 < _pos):
                farthest_pos17 = _pos
                farthest_err17 = _result
            _pos = farthest_pos17
            _result = farthest_err17
            break
        # End Choice
        if _status:
            arg27 = _result
            _result = lambda x: (5, 3, x)
            _status = True
            _result = _result(arg27)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack30
        # Option 4:
        # Begin Apply
        # ('<=' | '>=' | RequiredSpace('<' | '>')) |> `lambda x: (6, 3, x)`
        # Begin Choice
        farthest_err18 = _raise_error382
        backtrack32 = farthest_pos18 = _pos
        while True:
            # Option 1:
            # Begin Str
            value45 = '<='
            end45 = (_pos + 2)
            if (_text[slice(_pos, end45, None)] == value45):
                _result = value45
                _pos = (yield (3, _ctx._try__ignored, end45))[2]
                _status = True
            else:
                _result = _raise_error383
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Str
            value46 = '>='
            end46 = (_pos + 2)
            if (_text[slice(_pos, end46, None)] == value46):
                _result = value46
                _pos = (yield (3, _ctx._try__ignored, end46))[2]
                _status = True
            else:
                _result = _raise_error384
                _status = False
            # End Str
            if _status:
                break
            # Option 3:
            # Begin Call
            # RequiredSpace('<' | '>')
            func36 = _ParseFunction(_ctx._try_RequiredSpace, (_parse_function_387,), ())
            (_status, _result, _pos) = (yield (3, func36, _pos))
            # End Call
            if _status:
                break
            if (farthest_pos18 < _pos):
                farthest_pos18 = _pos
                farthest_err18 = _result
            _pos = farthest_pos18
            _result = farthest_err18
            break
        # End Choice
        if _status:
            arg28 = _result
            _result = lambda x: (6, 3, x)
            _status = True
            _result = _result(arg28)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack30
        # Option 5:
        # Begin Apply
        # ('in' | NotIn) |> `lambda x: (7, 3, x)`
        # Begin Choice
        farthest_err20 = _raise_error392
        backtrack33 = farthest_pos20 = _pos
        while True:
            # Option 1:
            # Begin Str
            value49 = 'in'
            end49 = (_pos + 2)
            if (_text[slice(_pos, end49, None)] == value49):
                _result = value49
                _pos = (yield (3, _ctx._try__ignored, end49))[2]
                _status = True
            else:
                _result = _raise_error393
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_NotIn, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos20 < _pos):
                farthest_pos20 = _pos
                farthest_err20 = _result
            _pos = farthest_pos20
            _result = farthest_err20
            break
        # End Choice
        if _status:
            arg29 = _result
            _result = lambda x: (7, 3, x)
            _status = True
            _result = _result(arg29)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack30
        # Option 6:
        # Begin Apply
        # ('==' | '!=') |> `lambda x: (8, 3, x)`
        # Begin Choice
        farthest_err21 = _raise_error397
        farthest_pos21 = _pos
        while True:
            # Option 1:
            # Begin Str
            value50 = '=='
            end50 = (_pos + 2)
            if (_text[slice(_pos, end50, None)] == value50):
                _result = value50
                _pos = (yield (3, _ctx._try__ignored, end50))[2]
                _status = True
            else:
                _result = _raise_error398
                _status = False
            # End Str
            if _status:
                break
            # Option 2:
            # Begin Str
            value51 = '!='
            end51 = (_pos + 2)
            if (_text[slice(_pos, end51, None)] == value51):
                _result = value51
                _pos = (yield (3, _ctx._try__ignored, end51))[2]
                _status = True
            else:
                _result = _raise_error399
                _status = False
            # End Str
            if _status:
                break
            _pos = farthest_pos21
            _result = farthest_err21
            break
        # End Choice
        if _status:
            arg30 = _result
            _result = lambda x: (8, 3, x)
            _status = True
            _result = _result(arg30)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack30
        # Option 7:
        # Begin Apply
        # '&' |> `lambda x: (9, 1, x)`
        # Begin Str
        value52 = '&'
        end52 = (_pos + 1)
        if (_text[slice(_pos, end52, None)] == value52):
            _result = value52
            _pos = (yield (3, _ctx._try__ignored, end52))[2]
            _status = True
        else:
            _result = _raise_error402
            _status = False
        # End Str
        if _status:
            arg31 = _result
            _result = lambda x: (9, 1, x)
            _status = True
            _result = _result(arg31)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack30
        # Option 8:
        # Begin Apply
        # '^' |> `lambda x: (10, 1, x)`
        # Begin Str
        value53 = '^'
        end53 = (_pos + 1)
        if (_text[slice(_pos, end53, None)] == value53):
            _result = value53
            _pos = (yield (3, _ctx._try__ignored, end53))[2]
            _status = True
        else:
            _result = _raise_error405
            _status = False
        # End Str
        if _status:
            arg32 = _result
            _result = lambda x: (10, 1, x)
            _status = True
            _result = _result(arg32)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack30
        # Option 9:
        # Begin Apply
        # wrap('|') |> `lambda x: (11, 1, x)`
        # Begin Call
        # wrap('|')
        arg33 = _wrap_string_literal('|', _parse_function_410)
        func37 = _ParseFunction(_ctx._try_wrap, (arg33,), ())
        (_status, _result, _pos) = (yield (3, func37, _pos))
        # End Call
        if _status:
            arg34 = _result
            _result = lambda x: (11, 1, x)
            _status = True
            _result = _result(arg34)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack30
        # Option 10:
        # Begin Apply
        # wrap(kw('and')) |> `lambda x: (13, 1, x)`
        # Begin Call
        # wrap(kw('and'))
        func39 = _ParseFunction(_ctx._try_wrap, (_parse_function_415,), ())
        (_status, _result, _pos) = (yield (3, func39, _pos))
        # End Call
        if _status:
            arg36 = _result
            _result = lambda x: (13, 1, x)
            _status = True
            _result = _result(arg36)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        _pos = backtrack30
        # Option 11:
        # Begin Apply
        # wrap(kw('or')) |> `lambda x: (14, 1, x)`
        # Begin Call
        # wrap(kw('or'))
        func41 = _ParseFunction(_ctx._try_wrap, (_parse_function_422,), ())
        (_status, _result, _pos) = (yield (3, func41, _pos))
        # End Call
        if _status:
            arg38 = _result
            _result = lambda x: (14, 1, x)
            _status = True
            _result = _result(arg38)
        # End Apply
        if _status:
            if not (has_result3):
                farthest_result3 = _result
                farthest_position3 = _pos
                has_result3 = True
            elif (farthest_position3 < _pos):
                farthest_result3 = _result
                farthest_position3 = _pos
        elif not has_result3 and ((farthest_error_position3 < _pos)):
            farthest_error_position3 = _pos
            farthest_error_result3 = _result
        if has_result3:
            _result = farthest_result3
            _pos = farthest_position3
            _status = True
        else:
            _result = farthest_error_result3
            _pos = farthest_error_position3
        # End Longest
        if not (_status):
            if _operand_stack1:
                _pos = _outer_checkpoint1
            break
        _prec = _result[0]
        while _operator_stack1:
            _top_prec, _top_assoc, _ = _operator_stack1[-1]
            if _top_prec < _prec or (_top_prec == _prec and _top_assoc == 1):
                _, _is_infix, _operator = _operator_stack1.pop()
                _right = _operand_stack1.pop()
                if _is_infix:
                    _left = _operand_stack1.pop()
                    _operand_stack1.append(Infix(_left, _operator, _right))
                else:
                    _operand_stack1.append(Prefix(_operator, _right))
            elif _top_prec == _prec and _top_assoc == 3:
                _pos = _outer_checkpoint1
                break
            else:
                break
        _operator_marker1 = len(_operator_stack1)
        _operator_stack1.append(_result)
    if _operand_stack1:
        _operator_stack1 = _operator_stack1[:_operator_marker1]
        while _operator_stack1:
            _, _is_infix, _operator = _operator_stack1.pop()
            _right = _operand_stack1.pop()
            if _is_infix:
                _left = _operand_stack1.pop()
                _operand_stack1.append(Infix(_left, _operator, _right))
            else:
                _operand_stack1.append(Prefix(_operator, _right))
        _result = _operand_stack1[0]
        _status = True
    # End OperatorTable
    yield (_status, _result, _pos)

def _parse_ValueExpression(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_ValueExpression, fullparse)

ValueExpression = ParsingRule('ValueExpression', _parse_ValueExpression, """
    ValueExpression = Name | LiteralExpression with operators {
        mixfix: ('(' >> wrap(ValueExpression)) << ')'
        postfix: ArgumentList, ElementAccess, FieldAccess, GenericArgumentList
        prefix: '-'
        left: '*', '/', '%'
        left: '+', '-'
        infix: wrap('<<'), wrap('>>')
        infix: '<=', '>=', RequiredSpace('<' | '>')
        infix: 'in', NotIn
        infix: '==', '!='
        left: '&'
        left: '^'
        left: wrap('|')
        prefix: kw('not')
        left: wrap(kw('and'))
        left: wrap(kw('or'))
        mixfix: If, Match
    }
""")
def _raise_error329(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    Name | LiteralExpression with operators {\n    mixfix: ('(' >> wrap(ValueExpression)) << ')'\n    postfix: ArgumentList, ElementAccess, FieldAccess, GenericArgumentList\n    prefix: '-'\n    left: '*', '/', '%'\n    left: '+', '-'\n    infix: wrap('<<'), wrap('>>')\n    infix: '<=', '>=', RequiredSpace('<' | '>')\n    infix: 'in', NotIn\n    infix: '==', '!='\n    left: '&'\n    left: '^'\n    left: wrap('|')\n    prefix: kw('not')\n    left: wrap(kw('and'))\n    left: wrap(kw('or'))\n    mixfix: If, Match\n}\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error330(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    Longest('-' |> `lambda x: (2, 0, x)`, kw('not') |> `lambda x: (12, 0, x)`)\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error332(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '-'\n\n"
    "Expected to match the string '-'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error337(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    'not'\n\n"
    "Expected to match the string 'not'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error339(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    Longest(Name | LiteralExpression, ('(' >> wrap(ValueExpression)) << ')', If | Match)\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error340(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    '    Name | LiteralExpression\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error345(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '('\n\n"
    "Expected to match the string '('"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error349(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    ')'\n\n"
    "Expected to match the string ')'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error350(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    '    If | Match\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error354(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    '    ArgumentList | ElementAccess | FieldAccess | GenericArgumentList\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error360(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    Longest(('*' | '/' | '%') |> `lambda x: (3, 1, x)`, ('+' | '-') |> `lambda x: (4, 1, x)`, (wrap('<<') | wrap('>>')) |> `lambda x: (5, 3, x)`, ('<=' | '>=' | RequiredSpace('<' | '>')) |> `lambda x: (6, 3, x)`, ('in' | NotIn) |> `lambda x: (7, 3, x)`, ('==' | '!=') |> `lambda x: (8, 3, x)`, '&' |> `lambda x: (9, 1, x)`, '^' |> `lambda x: (10, 1, x)`, wrap('|') |> `lambda x: (11, 1, x)`, wrap(kw('and')) |> `lambda x: (13, 1, x)`, wrap(kw('or')) |> `lambda x: (14, 1, x)`)\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error362(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '*' | '/' | '%'\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error363(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '*'\n\n"
    "Expected to match the string '*'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error364(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '/'\n\n"
    "Expected to match the string '/'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error365(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '%'\n\n"
    "Expected to match the string '%'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error368(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '+' | '-'\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error369(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '+'\n\n"
    "Expected to match the string '+'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error370(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '-'\n\n"
    "Expected to match the string '-'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error373(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    wrap('<<') | wrap('>>')\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error376(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '<<'\n\n"
    "Expected to match the string '<<'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error379(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '>>'\n\n"
    "Expected to match the string '>>'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error382(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '<=' | '>=' | RequiredSpace('<' | '>')\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error383(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '<='\n\n"
    "Expected to match the string '<='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error384(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '>='\n\n"
    "Expected to match the string '>='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error387(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '<' | '>'\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error388(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '<'\n\n"
    "Expected to match the string '<'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error389(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '>'\n\n"
    "Expected to match the string '>'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error392(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    'in' | NotIn\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error393(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    'in'\n\n"
    "Expected to match the string 'in'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error397(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '==' | '!='\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error398(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '=='\n\n"
    "Expected to match the string '=='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error399(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '!='\n\n"
    "Expected to match the string '!='"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error402(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '&'\n\n"
    "Expected to match the string '&'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error405(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '^'\n\n"
    "Expected to match the string '^'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error410(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    '|'\n\n"
    "Expected to match the string '|'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error417(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    'and'\n\n"
    "Expected to match the string 'and'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error424(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ValueExpression' rule, at the expression:\n"
    "    'or'\n\n"
    "Expected to match the string 'or'"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_NotIn(_ctx, _text, _pos):
    # Rule 'NotIn'
    # Begin Discard
    # /not[ \\t]+in/ >> `'not in'`
    while True:
        # Begin Regex
        # /not[ \\t]+in/
        match7 = matcher7(_text, _pos)
        if match7:
            _result = match7.group(0)
            _pos = (yield (3, _ctx._try__ignored, match7.end()))[2]
            _status = True
        else:
            _result = _raise_error428
            _status = False
        # End Regex
        if not (_status):
            break
        _result = 'not in'
        _status = True
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_NotIn(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_NotIn, fullparse)

NotIn = ParsingRule('NotIn', _parse_NotIn, """
    NotIn = /not[ \\t]+in/ >> `'not in'`
""")
def _raise_error428(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NotIn' rule, at the expression:\n"
    '    /not[ \\\\t]+in/\n\n'
    'Expected to match the regular expression /not[ \\t]+in/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_LiteralExpression(_ctx, _text, _pos):
    # Rule 'LiteralExpression'
    # Begin Choice
    farthest_err22 = _raise_error431
    backtrack34 = farthest_pos22 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_EmptyMapLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos22 < _pos):
            farthest_pos22 = _pos
            farthest_err22 = _result
        _pos = backtrack34
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ListLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos22 < _pos):
            farthest_pos22 = _pos
            farthest_err22 = _result
        _pos = backtrack34
        # Option 3:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_MapLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos22 < _pos):
            farthest_pos22 = _pos
            farthest_err22 = _result
        _pos = backtrack34
        # Option 4:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_NumberLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos22 < _pos):
            farthest_pos22 = _pos
            farthest_err22 = _result
        _pos = backtrack34
        # Option 5:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_SetLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos22 < _pos):
            farthest_pos22 = _pos
            farthest_err22 = _result
        _pos = backtrack34
        # Option 6:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_SymbolLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos22 < _pos):
            farthest_pos22 = _pos
            farthest_err22 = _result
        _pos = backtrack34
        # Option 7:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_TupleLiteral, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos22 < _pos):
            farthest_pos22 = _pos
            farthest_err22 = _result
        _pos = farthest_pos22
        _result = farthest_err22
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_LiteralExpression(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_LiteralExpression, fullparse)

LiteralExpression = ParsingRule('LiteralExpression', _parse_LiteralExpression, """
    LiteralExpression = EmptyMapLiteral | ListLiteral | MapLiteral | NumberLiteral | SetLiteral | SymbolLiteral | TupleLiteral
""")
def _raise_error431(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'LiteralExpression' rule, at the expression:\n"
    '    EmptyMapLiteral | ListLiteral | MapLiteral | NumberLiteral | SetLiteral | SymbolLiteral | TupleLiteral\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class EmptyMapLiteral(ParsedObject):
    """
    class EmptyMapLiteral {
        pass ('{' >> wrap(':')) << '}'
    }
    """
    _fields = ()

    def __init__(self):
        ParsedObject.__init__(self)

    def __repr__(self):
        return f'EmptyMapLiteral()'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_EmptyMapLiteral, fullparse)


def _parse_function_447(_ctx, _text, _pos):
    # Begin Str
    value58 = ':'
    end58 = (_pos + 1)
    if (_text[slice(_pos, end58, None)] == value58):
        _result = value58
        _pos = (yield (3, _ctx._try__ignored, end58))[2]
        _status = True
    else:
        _result = _raise_error447
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_EmptyMapLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos17 = _pos
    while True:
        # Begin Discard
        # ('{' >> wrap(':')) << '}'
        while True:
            # Begin Discard
            # '{' >> wrap(':')
            while True:
                # Begin Str
                value57 = '{'
                end57 = (_pos + 1)
                if (_text[slice(_pos, end57, None)] == value57):
                    _result = value57
                    _pos = (yield (3, _ctx._try__ignored, end57))[2]
                    _status = True
                else:
                    _result = _raise_error444
                    _status = False
                # End Str
                if not (_status):
                    break
                # Begin Call
                # wrap(':')
                arg39 = _wrap_string_literal(':', _parse_function_447)
                func42 = _ParseFunction(_ctx._try_wrap, (arg39,), ())
                (_status, _result, _pos) = (yield (3, func42, _pos))
                # End Call
                break
            # End Discard
            if not (_status):
                break
            staging7 = _result
            # Begin Str
            value59 = '}'
            end59 = (_pos + 1)
            if (_text[slice(_pos, end59, None)] == value59):
                _result = value59
                _pos = (yield (3, _ctx._try__ignored, end59))[2]
                _status = True
            else:
                _result = _raise_error448
                _status = False
            # End Str
            if _status:
                _result = staging7
            break
        # End Discard
        if not (_status):
            break
        item15 = _result
        _result = EmptyMapLiteral()
        _result._metadata.position_info = (start_pos17, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error444(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'EmptyMapLiteral' rule, at the expression:\n"
    "    '{'\n\n"
    "Expected to match the string '{'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error447(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'EmptyMapLiteral' rule, at the expression:\n"
    "    ':'\n\n"
    "Expected to match the string ':'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error448(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'EmptyMapLiteral' rule, at the expression:\n"
    "    '}'\n\n"
    "Expected to match the string '}'"
    )
    raise ParseError((title + details), _pos, line, col)

class ListLiteral(ParsedObject):
    """
    class ListLiteral {
        elements: SquareList(ValueExpression)
    }
    """
    _fields = ('elements',)

    def __init__(self, elements):
        ParsedObject.__init__(self)
        self.elements = elements

    def __repr__(self):
        return f'ListLiteral(elements={self.elements!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_ListLiteral, fullparse)


def _try_ListLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos18 = _pos
    while True:
        # Begin Call
        # SquareList(ValueExpression)
        func43 = _ParseFunction(_ctx._try_SquareList, (_try_ValueExpression,), ())
        (_status, _result, _pos) = (yield (3, func43, _pos))
        # End Call
        if not (_status):
            break
        elements = _result
        _result = ListLiteral(elements)
        _result._metadata.position_info = (start_pos18, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

class MapLiteral(ParsedObject):
    """
    class MapLiteral {
        pairs: CurlyList(Pair)
    }
    """
    _fields = ('pairs',)

    def __init__(self, pairs):
        ParsedObject.__init__(self)
        self.pairs = pairs

    def __repr__(self):
        return f'MapLiteral(pairs={self.pairs!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_MapLiteral, fullparse)


def _try_MapLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos19 = _pos
    while True:
        # Begin Call
        # CurlyList(Pair)
        func44 = _ParseFunction(_ctx._try_CurlyList, (_try_Pair,), ())
        (_status, _result, _pos) = (yield (3, func44, _pos))
        # End Call
        if not (_status):
            break
        pairs = _result
        _result = MapLiteral(pairs)
        _result._metadata.position_info = (start_pos19, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

class Pair(ParsedObject):
    """
    class Pair {
        key: ValueExpression
        value: ':' >> ValueExpression
    }
    """
    _fields = ('key', 'value')

    def __init__(self, key, value):
        ParsedObject.__init__(self)
        self.key = key
        self.value = value

    def __repr__(self):
        return f'Pair(key={self.key!r}, value={self.value!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Pair, fullparse)


def _try_Pair(_ctx, _text, _pos):
    # Begin Seq
    start_pos20 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        key = _result
        # Begin Discard
        # ':' >> ValueExpression
        while True:
            # Begin Str
            value60 = ':'
            end60 = (_pos + 1)
            if (_text[slice(_pos, end60, None)] == value60):
                _result = value60
                _pos = (yield (3, _ctx._try__ignored, end60))[2]
                _status = True
            else:
                _result = _raise_error467
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            break
        value = _result
        _result = Pair(key, value)
        _result._metadata.position_info = (start_pos20, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error467(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Pair' rule, at the expression:\n"
    "    ':'\n\n"
    "Expected to match the string ':'"
    )
    raise ParseError((title + details), _pos, line, col)

class NumberLiteral(ParsedObject):
    """
    class NumberLiteral {
        value: /\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+/
    }
    """
    _fields = ('value',)

    def __init__(self, value):
        ParsedObject.__init__(self)
        self.value = value

    def __repr__(self):
        return f'NumberLiteral(value={self.value!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_NumberLiteral, fullparse)


def _try_NumberLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos21 = _pos
    while True:
        # Begin Regex
        # /\\d+(\\.\\d*)?|\\.\\d+/
        match8 = matcher8(_text, _pos)
        if match8:
            _result = match8.group(0)
            _pos = (yield (3, _ctx._try__ignored, match8.end()))[2]
            _status = True
        else:
            _result = _raise_error472
            _status = False
        # End Regex
        if not (_status):
            break
        value = _result
        _result = NumberLiteral(value)
        _result._metadata.position_info = (start_pos21, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error472(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'NumberLiteral' rule, at the expression:\n"
    '    /\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+/\n\n'
    'Expected to match the regular expression /\\d+(\\.\\d*)?|\\.\\d+/'
    )
    raise ParseError((title + details), _pos, line, col)

class SetLiteral(ParsedObject):
    """
    class SetLiteral {
        elements: CurlyList(ValueExpression)
    }
    """
    _fields = ('elements',)

    def __init__(self, elements):
        ParsedObject.__init__(self)
        self.elements = elements

    def __repr__(self):
        return f'SetLiteral(elements={self.elements!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_SetLiteral, fullparse)


def _try_SetLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos22 = _pos
    while True:
        # Begin Call
        # CurlyList(ValueExpression)
        func45 = _ParseFunction(_ctx._try_CurlyList, (_try_ValueExpression,), ())
        (_status, _result, _pos) = (yield (3, func45, _pos))
        # End Call
        if not (_status):
            break
        elements = _result
        _result = SetLiteral(elements)
        _result._metadata.position_info = (start_pos22, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

class SymbolLiteral(ParsedObject):
    """
    class SymbolLiteral {
        contents: /"(?:[^\\\\\\\\"]|\\\\\\\\.)*"/ |> `literal_eval`
    }
    """
    _fields = ('contents',)

    def __init__(self, contents):
        ParsedObject.__init__(self)
        self.contents = contents

    def __repr__(self):
        return f'SymbolLiteral(contents={self.contents!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_SymbolLiteral, fullparse)


def _try_SymbolLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos23 = _pos
    while True:
        # Begin Apply
        # /"(?:[^\\\\"]|\\\\.)*"/ |> `literal_eval`
        # Begin Regex
        # /"(?:[^\\\\"]|\\\\.)*"/
        match9 = matcher9(_text, _pos)
        if match9:
            _result = match9.group(0)
            _pos = (yield (3, _ctx._try__ignored, match9.end()))[2]
            _status = True
        else:
            _result = _raise_error483
            _status = False
        # End Regex
        if _status:
            arg40 = _result
            _result = literal_eval
            _status = True
            _result = _result(arg40)
        # End Apply
        if not (_status):
            break
        contents = _result
        _result = SymbolLiteral(contents)
        _result._metadata.position_info = (start_pos23, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error483(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'SymbolLiteral' rule, at the expression:\n"
    '    /"(?:[^\\\\\\\\"]|\\\\\\\\.)*"/\n\n'
    'Expected to match the regular expression /"(?:[^\\\\"]|\\\\.)*"/'
    )
    raise ParseError((title + details), _pos, line, col)

class TupleLiteral(ParsedObject):
    """
    class TupleLiteral {
        pass '('
        elements: wrap(Sep(ValueExpression, Comma, allow_trailer=true, require_separator=True))
        pass ')'
    }
    """
    _fields = ('elements',)

    def __init__(self, elements):
        ParsedObject.__init__(self)
        self.elements = elements

    def __repr__(self):
        return f'TupleLiteral(elements={self.elements!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_TupleLiteral, fullparse)


def _parse_function_492(_ctx, _text, _pos):
    # Begin Sep
    # Sep(ValueExpression, Comma, allow_trailer=true, require_separator=True)
    staging8 = []
    checkpoint2 = _pos
    saw_separator1 = False
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        staging8.append(_result)
        checkpoint2 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Comma, _pos))
        # End Ref
        if not (_status):
            break
        checkpoint2 = _pos
        saw_separator1 = True
    if not staging8 or saw_separator1:
        _result = staging8
        _pos = checkpoint2
        _status = True
    # End Sep
    yield (_status, _result, _pos)

def _try_TupleLiteral(_ctx, _text, _pos):
    # Begin Seq
    start_pos24 = _pos
    while True:
        # Begin Str
        value61 = '('
        end61 = (_pos + 1)
        if (_text[slice(_pos, end61, None)] == value61):
            _result = value61
            _pos = (yield (3, _ctx._try__ignored, end61))[2]
            _status = True
        else:
            _result = _raise_error488
            _status = False
        # End Str
        if not (_status):
            break
        item16 = _result
        # Begin Call
        # wrap(Sep(ValueExpression, Comma, allow_trailer=true, require_separator=True))
        func46 = _ParseFunction(_ctx._try_wrap, (_parse_function_492,), ())
        (_status, _result, _pos) = (yield (3, func46, _pos))
        # End Call
        if not (_status):
            break
        elements = _result
        # Begin Str
        value62 = ')'
        end62 = (_pos + 1)
        if (_text[slice(_pos, end62, None)] == value62):
            _result = value62
            _pos = (yield (3, _ctx._try__ignored, end62))[2]
            _status = True
        else:
            _result = _raise_error498
            _status = False
        # End Str
        if not (_status):
            break
        item17 = _result
        _result = TupleLiteral(elements)
        _result._metadata.position_info = (start_pos24, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error488(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'TupleLiteral' rule, at the expression:\n"
    "    '('\n\n"
    "Expected to match the string '('"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error498(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'TupleLiteral' rule, at the expression:\n"
    "    ')'\n\n"
    "Expected to match the string ')'"
    )
    raise ParseError((title + details), _pos, line, col)

class ArgumentList(ParsedObject):
    """
    class ArgumentList {
        arguments: ParenthesesList(ValueExpression | KeywordArgument)
    }
    """
    _fields = ('arguments',)

    def __init__(self, arguments):
        ParsedObject.__init__(self)
        self.arguments = arguments

    def __repr__(self):
        return f'ArgumentList(arguments={self.arguments!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_ArgumentList, fullparse)


def _parse_function_504(_ctx, _text, _pos):
    # Begin Choice
    farthest_err23 = _raise_error504
    backtrack35 = farthest_pos23 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos23 < _pos):
            farthest_pos23 = _pos
            farthest_err23 = _result
        _pos = backtrack35
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_KeywordArgument, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos23 < _pos):
            farthest_pos23 = _pos
            farthest_err23 = _result
        _pos = farthest_pos23
        _result = farthest_err23
        break
    # End Choice
    yield (_status, _result, _pos)

def _try_ArgumentList(_ctx, _text, _pos):
    # Begin Seq
    start_pos25 = _pos
    while True:
        # Begin Call
        # ParenthesesList(ValueExpression | KeywordArgument)
        func47 = _ParseFunction(_ctx._try_ParenthesesList, (_parse_function_504,), ())
        (_status, _result, _pos) = (yield (3, func47, _pos))
        # End Call
        if not (_status):
            break
        arguments = _result
        _result = ArgumentList(arguments)
        _result._metadata.position_info = (start_pos25, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error504(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ArgumentList' rule, at the expression:\n"
    '    ValueExpression | KeywordArgument\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class GenericArgumentList(ParsedObject):
    """
    class GenericArgumentList {
        arguments: (ForbiddenSpace('<') >> (GenericArgument /? Comma)) << ForbiddenSpace('>')
    }
    """
    _fields = ('arguments',)

    def __init__(self, arguments):
        ParsedObject.__init__(self)
        self.arguments = arguments

    def __repr__(self):
        return f'GenericArgumentList(arguments={self.arguments!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_GenericArgumentList, fullparse)


def _parse_function_514(_ctx, _text, _pos):
    # Begin Str
    value63 = '<'
    end63 = (_pos + 1)
    if (_text[slice(_pos, end63, None)] == value63):
        _result = value63
        _pos = (yield (3, _ctx._try__ignored, end63))[2]
        _status = True
    else:
        _result = _raise_error514
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_520(_ctx, _text, _pos):
    # Begin Str
    value64 = '>'
    end64 = (_pos + 1)
    if (_text[slice(_pos, end64, None)] == value64):
        _result = value64
        _pos = (yield (3, _ctx._try__ignored, end64))[2]
        _status = True
    else:
        _result = _raise_error520
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_GenericArgumentList(_ctx, _text, _pos):
    # Begin Seq
    start_pos26 = _pos
    while True:
        # Begin Discard
        # (ForbiddenSpace('<') >> (GenericArgument /? Comma)) << ForbiddenSpace('>')
        while True:
            # Begin Discard
            # ForbiddenSpace('<') >> (GenericArgument /? Comma)
            while True:
                # Begin Call
                # ForbiddenSpace('<')
                arg41 = _wrap_string_literal('<', _parse_function_514)
                func48 = _ParseFunction(_ctx._try_ForbiddenSpace, (arg41,), ())
                (_status, _result, _pos) = (yield (3, func48, _pos))
                # End Call
                if not (_status):
                    break
                # Begin Sep
                # GenericArgument /? Comma
                staging9 = []
                checkpoint3 = _pos
                while True:
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _ctx._try_GenericArgument, _pos))
                    # End Ref
                    if not (_status):
                        break
                    staging9.append(_result)
                    checkpoint3 = _pos
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _ctx._try_Comma, _pos))
                    # End Ref
                    if not (_status):
                        break
                    checkpoint3 = _pos
                _result = staging9
                _pos = checkpoint3
                _status = True
                # End Sep
                break
            # End Discard
            if not (_status):
                break
            staging10 = _result
            # Begin Call
            # ForbiddenSpace('>')
            arg42 = _wrap_string_literal('>', _parse_function_520)
            func49 = _ParseFunction(_ctx._try_ForbiddenSpace, (arg42,), ())
            (_status, _result, _pos) = (yield (3, func49, _pos))
            # End Call
            if _status:
                _result = staging10
            break
        # End Discard
        if not (_status):
            break
        arguments = _result
        _result = GenericArgumentList(arguments)
        _result._metadata.position_info = (start_pos26, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error514(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'GenericArgumentList' rule, at the expression:\n"
    "    '<'\n\n"
    "Expected to match the string '<'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error520(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'GenericArgumentList' rule, at the expression:\n"
    "    '>'\n\n"
    "Expected to match the string '>'"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_GenericArgument(_ctx, _text, _pos):
    # Rule 'GenericArgument'
    # Begin Choice
    farthest_err24 = _raise_error522
    backtrack36 = farthest_pos24 = _pos
    while True:
        # Option 1:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_KeywordTypeArgument, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos24 < _pos):
            farthest_pos24 = _pos
            farthest_err24 = _result
        _pos = backtrack36
        # Option 2:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_TypeExpression, _pos))
        # End Ref
        if _status:
            break
        if (farthest_pos24 < _pos):
            farthest_pos24 = _pos
            farthest_err24 = _result
        _pos = farthest_pos24
        _result = farthest_err24
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_GenericArgument(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_GenericArgument, fullparse)

GenericArgument = ParsingRule('GenericArgument', _parse_GenericArgument, """
    GenericArgument = KeywordTypeArgument | TypeExpression
""")
def _raise_error522(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'GenericArgument' rule, at the expression:\n"
    '    KeywordTypeArgument | TypeExpression\n\n'
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

class KeywordArgument(ParsedObject):
    """
    class KeywordArgument {
        name: Word
        pass '='
        value: ValueExpression
    }
    """
    _fields = ('name', 'value')

    def __init__(self, name, value):
        ParsedObject.__init__(self)
        self.name = name
        self.value = value

    def __repr__(self):
        return f'KeywordArgument(name={self.name!r}, value={self.value!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_KeywordArgument, fullparse)


def _try_KeywordArgument(_ctx, _text, _pos):
    # Begin Seq
    start_pos27 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Word, _pos))
        # End Ref
        if not (_status):
            break
        name = _result
        # Begin Str
        value65 = '='
        end65 = (_pos + 1)
        if (_text[slice(_pos, end65, None)] == value65):
            _result = value65
            _pos = (yield (3, _ctx._try__ignored, end65))[2]
            _status = True
        else:
            _result = _raise_error530
            _status = False
        # End Str
        if not (_status):
            break
        item18 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        value = _result
        _result = KeywordArgument(name, value)
        _result._metadata.position_info = (start_pos27, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error530(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'KeywordArgument' rule, at the expression:\n"
    "    '='\n\n"
    "Expected to match the string '='"
    )
    raise ParseError((title + details), _pos, line, col)

class KeywordTypeArgument(ParsedObject):
    """
    class KeywordTypeArgument {
        name: Word
        pass '='
        value: TypeExpression
    }
    """
    _fields = ('name', 'value')

    def __init__(self, name, value):
        ParsedObject.__init__(self)
        self.name = name
        self.value = value

    def __repr__(self):
        return f'KeywordTypeArgument(name={self.name!r}, value={self.value!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_KeywordTypeArgument, fullparse)


def _try_KeywordTypeArgument(_ctx, _text, _pos):
    # Begin Seq
    start_pos28 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Word, _pos))
        # End Ref
        if not (_status):
            break
        name = _result
        # Begin Str
        value66 = '='
        end66 = (_pos + 1)
        if (_text[slice(_pos, end66, None)] == value66):
            _result = value66
            _pos = (yield (3, _ctx._try__ignored, end66))[2]
            _status = True
        else:
            _result = _raise_error538
            _status = False
        # End Str
        if not (_status):
            break
        item19 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_TypeExpression, _pos))
        # End Ref
        if not (_status):
            break
        value = _result
        _result = KeywordTypeArgument(name, value)
        _result._metadata.position_info = (start_pos28, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error538(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'KeywordTypeArgument' rule, at the expression:\n"
    "    '='\n\n"
    "Expected to match the string '='"
    )
    raise ParseError((title + details), _pos, line, col)

class ElementAccess(ParsedObject):
    """
    class ElementAccess {
        indexes: SquareList(ValueExpression)
    }
    """
    _fields = ('indexes',)

    def __init__(self, indexes):
        ParsedObject.__init__(self)
        self.indexes = indexes

    def __repr__(self):
        return f'ElementAccess(indexes={self.indexes!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_ElementAccess, fullparse)


def _try_ElementAccess(_ctx, _text, _pos):
    # Begin Seq
    start_pos29 = _pos
    while True:
        # Begin Call
        # SquareList(ValueExpression)
        func50 = _ParseFunction(_ctx._try_SquareList, (_try_ValueExpression,), ())
        (_status, _result, _pos) = (yield (3, func50, _pos))
        # End Call
        if not (_status):
            break
        indexes = _result
        _result = ElementAccess(indexes)
        _result._metadata.position_info = (start_pos29, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

class FieldAccess(ParsedObject):
    """
    class FieldAccess {
        field: '.' >> Word
    }
    """
    _fields = ('field',)

    def __init__(self, field):
        ParsedObject.__init__(self)
        self.field = field

    def __repr__(self):
        return f'FieldAccess(field={self.field!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_FieldAccess, fullparse)


def _try_FieldAccess(_ctx, _text, _pos):
    # Begin Seq
    start_pos30 = _pos
    while True:
        # Begin Discard
        # '.' >> Word
        while True:
            # Begin Str
            value67 = '.'
            end67 = (_pos + 1)
            if (_text[slice(_pos, end67, None)] == value67):
                _result = value67
                _pos = (yield (3, _ctx._try__ignored, end67))[2]
                _status = True
            else:
                _result = _raise_error551
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Word, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            break
        field = _result
        _result = FieldAccess(field)
        _result._metadata.position_info = (start_pos30, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error551(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'FieldAccess' rule, at the expression:\n"
    "    '.'\n\n"
    "Expected to match the string '.'"
    )
    raise ParseError((title + details), _pos, line, col)

class If(ParsedObject):
    """
    class If {
        pass kw('if')
        condition: ValueExpression
        then_branch: Block(Statement)
        else_branch: Opt(kw('else') >> Block(Statement))
    }
    """
    _fields = ('condition', 'then_branch', 'else_branch')

    def __init__(self, condition, then_branch, else_branch):
        ParsedObject.__init__(self)
        self.condition = condition
        self.then_branch = then_branch
        self.else_branch = else_branch

    def __repr__(self):
        return f'If(condition={self.condition!r}, then_branch={self.then_branch!r}, else_branch={self.else_branch!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_If, fullparse)


def _parse_function_558(_ctx, _text, _pos):
    # Begin Str
    value68 = 'if'
    end68 = (_pos + 2)
    if (_text[slice(_pos, end68, None)] == value68):
        _result = value68
        _pos = (yield (3, _ctx._try__ignored, end68))[2]
        _status = True
    else:
        _result = _raise_error558
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_570(_ctx, _text, _pos):
    # Begin Str
    value69 = 'else'
    end69 = (_pos + 4)
    if (_text[slice(_pos, end69, None)] == value69):
        _result = value69
        _pos = (yield (3, _ctx._try__ignored, end69))[2]
        _status = True
    else:
        _result = _raise_error570
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_If(_ctx, _text, _pos):
    # Begin Seq
    start_pos31 = _pos
    while True:
        # Begin Call
        # kw('if')
        arg43 = _wrap_string_literal('if', _parse_function_558)
        func51 = _ParseFunction(_ctx._try_kw, (arg43,), ())
        (_status, _result, _pos) = (yield (3, func51, _pos))
        # End Call
        if not (_status):
            break
        item20 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        condition = _result
        # Begin Call
        # Block(Statement)
        func52 = _ParseFunction(_ctx._try_Block, (_try_Statement,), ())
        (_status, _result, _pos) = (yield (3, func52, _pos))
        # End Call
        if not (_status):
            break
        then_branch = _result
        # Begin Opt
        # Opt(kw('else') >> Block(Statement))
        backtrack37 = _pos
        # Begin Discard
        # kw('else') >> Block(Statement)
        while True:
            # Begin Call
            # kw('else')
            arg44 = _wrap_string_literal('else', _parse_function_570)
            func53 = _ParseFunction(_ctx._try_kw, (arg44,), ())
            (_status, _result, _pos) = (yield (3, func53, _pos))
            # End Call
            if not (_status):
                break
            # Begin Call
            # Block(Statement)
            func54 = _ParseFunction(_ctx._try_Block, (_try_Statement,), ())
            (_status, _result, _pos) = (yield (3, func54, _pos))
            # End Call
            break
        # End Discard
        if not (_status):
            _pos = backtrack37
            _result = None
            _status = True
        # End Opt
        else_branch = _result
        _result = If(condition, then_branch, else_branch)
        _result._metadata.position_info = (start_pos31, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error558(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'If' rule, at the expression:\n"
    "    'if'\n\n"
    "Expected to match the string 'if'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error570(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'If' rule, at the expression:\n"
    "    'else'\n\n"
    "Expected to match the string 'else'"
    )
    raise ParseError((title + details), _pos, line, col)

class Match(ParsedObject):
    """
    class Match {
        pass kw('match')
        value: ValueExpression
        cases: Block(MatchCase)
    }
    """
    _fields = ('value', 'cases')

    def __init__(self, value, cases):
        ParsedObject.__init__(self)
        self.value = value
        self.cases = cases

    def __repr__(self):
        return f'Match(value={self.value!r}, cases={self.cases!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Match, fullparse)


def _parse_function_579(_ctx, _text, _pos):
    # Begin Str
    value70 = 'match'
    end70 = (_pos + 5)
    if (_text[slice(_pos, end70, None)] == value70):
        _result = value70
        _pos = (yield (3, _ctx._try__ignored, end70))[2]
        _status = True
    else:
        _result = _raise_error579
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Match(_ctx, _text, _pos):
    # Begin Seq
    start_pos32 = _pos
    while True:
        # Begin Call
        # kw('match')
        arg45 = _wrap_string_literal('match', _parse_function_579)
        func55 = _ParseFunction(_ctx._try_kw, (arg45,), ())
        (_status, _result, _pos) = (yield (3, func55, _pos))
        # End Call
        if not (_status):
            break
        item21 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
        # End Ref
        if not (_status):
            break
        value = _result
        # Begin Call
        # Block(MatchCase)
        func56 = _ParseFunction(_ctx._try_Block, (_try_MatchCase,), ())
        (_status, _result, _pos) = (yield (3, func56, _pos))
        # End Call
        if not (_status):
            break
        cases = _result
        _result = Match(value, cases)
        _result._metadata.position_info = (start_pos32, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error579(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Match' rule, at the expression:\n"
    "    'match'\n\n"
    "Expected to match the string 'match'"
    )
    raise ParseError((title + details), _pos, line, col)

class MatchCase(ParsedObject):
    """
    class MatchCase {
        pass kw('case')
        pattern: Opt(ValueExpression | '*')
        guard: Opt(kw('if') >> ValueExpression)
        body: Block(Statement)
    }
    """
    _fields = ('pattern', 'guard', 'body')

    def __init__(self, pattern, guard, body):
        ParsedObject.__init__(self)
        self.pattern = pattern
        self.guard = guard
        self.body = body

    def __repr__(self):
        return f'MatchCase(pattern={self.pattern!r}, guard={self.guard!r}, body={self.body!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_MatchCase, fullparse)


def _parse_function_591(_ctx, _text, _pos):
    # Begin Str
    value71 = 'case'
    end71 = (_pos + 4)
    if (_text[slice(_pos, end71, None)] == value71):
        _result = value71
        _pos = (yield (3, _ctx._try__ignored, end71))[2]
        _status = True
    else:
        _result = _raise_error591
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_602(_ctx, _text, _pos):
    # Begin Str
    value73 = 'if'
    end73 = (_pos + 2)
    if (_text[slice(_pos, end73, None)] == value73):
        _result = value73
        _pos = (yield (3, _ctx._try__ignored, end73))[2]
        _status = True
    else:
        _result = _raise_error602
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_MatchCase(_ctx, _text, _pos):
    # Begin Seq
    start_pos33 = _pos
    while True:
        # Begin Call
        # kw('case')
        arg46 = _wrap_string_literal('case', _parse_function_591)
        func57 = _ParseFunction(_ctx._try_kw, (arg46,), ())
        (_status, _result, _pos) = (yield (3, func57, _pos))
        # End Call
        if not (_status):
            break
        item22 = _result
        # Begin Opt
        # Opt(ValueExpression | '*')
        backtrack38 = _pos
        # Begin Choice
        farthest_err25 = _raise_error594
        backtrack39 = farthest_pos25 = _pos
        while True:
            # Option 1:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            if _status:
                break
            if (farthest_pos25 < _pos):
                farthest_pos25 = _pos
                farthest_err25 = _result
            _pos = backtrack39
            # Option 2:
            # Begin Str
            value72 = '*'
            end72 = (_pos + 1)
            if (_text[slice(_pos, end72, None)] == value72):
                _result = value72
                _pos = (yield (3, _ctx._try__ignored, end72))[2]
                _status = True
            else:
                _result = _raise_error596
                _status = False
            # End Str
            if _status:
                break
            _pos = farthest_pos25
            _result = farthest_err25
            break
        # End Choice
        if not (_status):
            _pos = backtrack38
            _result = None
            _status = True
        # End Opt
        pattern = _result
        # Begin Opt
        # Opt(kw('if') >> ValueExpression)
        backtrack40 = _pos
        # Begin Discard
        # kw('if') >> ValueExpression
        while True:
            # Begin Call
            # kw('if')
            arg47 = _wrap_string_literal('if', _parse_function_602)
            func58 = _ParseFunction(_ctx._try_kw, (arg47,), ())
            (_status, _result, _pos) = (yield (3, func58, _pos))
            # End Call
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack40
            _result = None
            _status = True
        # End Opt
        guard = _result
        # Begin Call
        # Block(Statement)
        func59 = _ParseFunction(_ctx._try_Block, (_try_Statement,), ())
        (_status, _result, _pos) = (yield (3, func59, _pos))
        # End Call
        if not (_status):
            break
        body = _result
        _result = MatchCase(pattern, guard, body)
        _result._metadata.position_info = (start_pos33, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error591(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MatchCase' rule, at the expression:\n"
    "    'case'\n\n"
    "Expected to match the string 'case'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error594(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MatchCase' rule, at the expression:\n"
    "    ValueExpression | '*'\n\n"
    'Unexpected input'
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error596(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MatchCase' rule, at the expression:\n"
    "    '*'\n\n"
    "Expected to match the string '*'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error602(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'MatchCase' rule, at the expression:\n"
    "    'if'\n\n"
    "Expected to match the string 'if'"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Block(_ctx, _text, _pos, T):
    # Rule 'Block'
    # Begin Discard
    # ((((Pad >> '{') >> Pad) >> (T /? LineSep)) << Pad) << '}'
    while True:
        # Begin Discard
        # (((Pad >> '{') >> Pad) >> (T /? LineSep)) << Pad
        while True:
            # Begin Discard
            # ((Pad >> '{') >> Pad) >> (T /? LineSep)
            while True:
                # Begin Discard
                # (Pad >> '{') >> Pad
                while True:
                    # Begin Discard
                    # Pad >> '{'
                    while True:
                        # Begin Ref
                        (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                        # End Ref
                        if not (_status):
                            break
                        # Begin Str
                        value74 = '{'
                        end74 = (_pos + 1)
                        if (_text[slice(_pos, end74, None)] == value74):
                            _result = value74
                            _pos = (yield (3, _ctx._try__ignored, end74))[2]
                            _status = True
                        else:
                            _result = _raise_error615
                            _status = False
                        # End Str
                        break
                    # End Discard
                    if not (_status):
                        break
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                    # End Ref
                    break
                # End Discard
                if not (_status):
                    break
                # Begin Sep
                # T /? LineSep
                staging11 = []
                checkpoint4 = _pos
                while True:
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, T, _pos))
                    # End Ref
                    if not (_status):
                        break
                    staging11.append(_result)
                    checkpoint4 = _pos
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _ctx._try_LineSep, _pos))
                    # End Ref
                    if not (_status):
                        break
                    checkpoint4 = _pos
                _result = staging11
                _pos = checkpoint4
                _status = True
                # End Sep
                break
            # End Discard
            if not (_status):
                break
            staging12 = _result
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
            # End Ref
            if _status:
                _result = staging12
            break
        # End Discard
        if not (_status):
            break
        staging13 = _result
        # Begin Str
        value75 = '}'
        end75 = (_pos + 1)
        if (_text[slice(_pos, end75, None)] == value75):
            _result = value75
            _pos = (yield (3, _ctx._try__ignored, end75))[2]
            _status = True
        else:
            _result = _raise_error621
            _status = False
        # End Str
        if _status:
            _result = staging13
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_Block(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Block, fullparse)

Block = ParsingRule('Block', _parse_Block, """
    Block(T) = ((((Pad >> '{') >> Pad) >> (T /? LineSep)) << Pad) << '}'
""")
def _raise_error615(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Block' rule, at the expression:\n"
    "    '{'\n\n"
    "Expected to match the string '{'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error621(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Block' rule, at the expression:\n"
    "    '}'\n\n"
    "Expected to match the string '}'"
    )
    raise ParseError((title + details), _pos, line, col)

def _parse_function_625(_ctx, _text, _pos):
    # Begin Str
    value76 = ','
    end76 = (_pos + 1)
    if (_text[slice(_pos, end76, None)] == value76):
        _result = value76
        _pos = (yield (3, _ctx._try__ignored, end76))[2]
        _status = True
    else:
        _result = _raise_error625
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_Comma(_ctx, _text, _pos):
    # Rule 'Comma'
    # Begin Call
    # wrap(',')
    arg48 = _wrap_string_literal(',', _parse_function_625)
    func60 = _ParseFunction(_ctx._try_wrap, (arg48,), ())
    (_status, _result, _pos) = (yield (3, func60, _pos))
    # End Call
    yield (_status, _result, _pos)

def _parse_Comma(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Comma, fullparse)

Comma = ParsingRule('Comma', _parse_Comma, """
    Comma = wrap(',')
""")
def _raise_error625(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Comma' rule, at the expression:\n"
    "    ','\n\n"
    "Expected to match the string ','"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_LineSep(_ctx, _text, _pos):
    # Rule 'LineSep'
    # Begin List
    # /[\\n\\r]+/+
    staging14 = []
    while True:
        # Begin Regex
        # /[\\n\\r]+/
        match10 = matcher10(_text, _pos)
        if match10:
            _result = match10.group(0)
            _pos = (yield (3, _ctx._try__ignored, match10.end()))[2]
            _status = True
        else:
            _result = _raise_error628
            _status = False
        # End Regex
        if not (_status):
            break
        staging14.append(_result)
    if staging14:
        _result = staging14
        _status = True
    # End List
    yield (_status, _result, _pos)

def _parse_LineSep(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_LineSep, fullparse)

LineSep = ParsingRule('LineSep', _parse_LineSep, """
    LineSep = /[\\n\\r]+/+
""")
def _raise_error628(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'LineSep' rule, at the expression:\n"
    '    /[\\\\n\\\\r]+/\n\n'
    'Expected to match the regular expression /[\\n\\r]+/'
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Lines(_ctx, _text, _pos, T):
    # Rule 'Lines'
    # Begin Sep
    # T /? LineSep
    staging15 = []
    checkpoint5 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, T, _pos))
        # End Ref
        if not (_status):
            break
        staging15.append(_result)
        checkpoint5 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_LineSep, _pos))
        # End Ref
        if not (_status):
            break
        checkpoint5 = _pos
    _result = staging15
    _pos = checkpoint5
    _status = True
    # End Sep
    yield (_status, _result, _pos)

def _parse_Lines(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Lines, fullparse)

Lines = ParsingRule('Lines', _parse_Lines, """
    Lines(T) = T /? LineSep
""")
class Parameter(ParsedObject):
    """
    class Parameter {
        name: Name
        type: Opt(':' >> TypeExpression)
        default: Opt('=' >> ValueExpression)
    }
    """
    _fields = ('name', 'type', 'default')

    def __init__(self, name, type, default):
        ParsedObject.__init__(self)
        self.name = name
        self.type = type
        self.default = default

    def __repr__(self):
        return f'Parameter(name={self.name!r}, type={self.type!r}, default={self.default!r})'

    @staticmethod
    def parse(text, pos=0, fullparse=True):
        return _run(_ctx, text, pos, _ctx._try_Parameter, fullparse)


def _try_Parameter(_ctx, _text, _pos):
    # Begin Seq
    start_pos34 = _pos
    while True:
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
        # End Ref
        if not (_status):
            break
        name = _result
        # Begin Opt
        # Opt(':' >> TypeExpression)
        backtrack41 = _pos
        # Begin Discard
        # ':' >> TypeExpression
        while True:
            # Begin Str
            value77 = ':'
            end77 = (_pos + 1)
            if (_text[slice(_pos, end77, None)] == value77):
                _result = value77
                _pos = (yield (3, _ctx._try__ignored, end77))[2]
                _status = True
            else:
                _result = _raise_error640
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_TypeExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack41
            _result = None
            _status = True
        # End Opt
        type = _result
        # Begin Opt
        # Opt('=' >> ValueExpression)
        backtrack42 = _pos
        # Begin Discard
        # '=' >> ValueExpression
        while True:
            # Begin Str
            value78 = '='
            end78 = (_pos + 1)
            if (_text[slice(_pos, end78, None)] == value78):
                _result = value78
                _pos = (yield (3, _ctx._try__ignored, end78))[2]
                _status = True
            else:
                _result = _raise_error645
                _status = False
            # End Str
            if not (_status):
                break
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_ValueExpression, _pos))
            # End Ref
            break
        # End Discard
        if not (_status):
            _pos = backtrack42
            _result = None
            _status = True
        # End Opt
        default = _result
        _result = Parameter(name, type, default)
        _result._metadata.position_info = (start_pos34, _pos)
        break
    # End Seq
    yield (_status, _result, _pos)

def _raise_error640(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Parameter' rule, at the expression:\n"
    "    ':'\n\n"
    "Expected to match the string ':'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error645(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'Parameter' rule, at the expression:\n"
    "    '='\n\n"
    "Expected to match the string '='"
    )
    raise ParseError((title + details), _pos, line, col)

def _try_Names(_ctx, _text, _pos):
    # Rule 'Names'
    # Begin Choice
    backtrack43 = _pos
    while True:
        # Option 1: (always_succeeds)
        # Begin Sep
        # Name /? Comma
        staging16 = []
        checkpoint6 = _pos
        while True:
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Name, _pos))
            # End Ref
            if not (_status):
                break
            staging16.append(_result)
            checkpoint6 = _pos
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Comma, _pos))
            # End Ref
            if not (_status):
                break
            checkpoint6 = _pos
        _result = staging16
        _pos = checkpoint6
        _status = True
        # End Sep
        break
    # End Choice
    yield (_status, _result, _pos)

def _parse_Names(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_Names, fullparse)

Names = ParsingRule('Names', _parse_Names, """
    Names = Name /? Comma | ParenthesesList(Name)
""")
def _try_SurroundedList(_ctx, _text, _pos, L, T, R):
    # Rule 'SurroundedList'
    # Begin Discard
    # (((L >> Pad) >> (T /? Comma)) << Pad) << R
    while True:
        # Begin Discard
        # ((L >> Pad) >> (T /? Comma)) << Pad
        while True:
            # Begin Discard
            # (L >> Pad) >> (T /? Comma)
            while True:
                # Begin Discard
                # L >> Pad
                while True:
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, L, _pos))
                    # End Ref
                    if not (_status):
                        break
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
                    # End Ref
                    break
                # End Discard
                if not (_status):
                    break
                # Begin Sep
                # T /? Comma
                staging17 = []
                checkpoint7 = _pos
                while True:
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, T, _pos))
                    # End Ref
                    if not (_status):
                        break
                    staging17.append(_result)
                    checkpoint7 = _pos
                    # Begin Ref
                    (_status, _result, _pos) = (yield (3, _ctx._try_Comma, _pos))
                    # End Ref
                    if not (_status):
                        break
                    checkpoint7 = _pos
                _result = staging17
                _pos = checkpoint7
                _status = True
                # End Sep
                break
            # End Discard
            if not (_status):
                break
            staging18 = _result
            # Begin Ref
            (_status, _result, _pos) = (yield (3, _ctx._try_Pad, _pos))
            # End Ref
            if _status:
                _result = staging18
            break
        # End Discard
        if not (_status):
            break
        staging19 = _result
        # Begin Ref
        (_status, _result, _pos) = (yield (3, R, _pos))
        # End Ref
        if _status:
            _result = staging19
        break
    # End Discard
    yield (_status, _result, _pos)

def _parse_SurroundedList(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_SurroundedList, fullparse)

SurroundedList = ParsingRule('SurroundedList', _parse_SurroundedList, """
    SurroundedList(L, T, R) = (((L >> Pad) >> (T /? Comma)) << Pad) << R
""")
def _parse_function_670(_ctx, _text, _pos):
    # Begin Str
    value79 = '{'
    end79 = (_pos + 1)
    if (_text[slice(_pos, end79, None)] == value79):
        _result = value79
        _pos = (yield (3, _ctx._try__ignored, end79))[2]
        _status = True
    else:
        _result = _raise_error670
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_672(_ctx, _text, _pos):
    # Begin Str
    value80 = '}'
    end80 = (_pos + 1)
    if (_text[slice(_pos, end80, None)] == value80):
        _result = value80
        _pos = (yield (3, _ctx._try__ignored, end80))[2]
        _status = True
    else:
        _result = _raise_error672
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_CurlyList(_ctx, _text, _pos, T):
    # Rule 'CurlyList'
    # Begin Call
    # SurroundedList('{', T, '}')
    arg49 = _wrap_string_literal('{', _parse_function_670)
    arg50 = _wrap_string_literal('}', _parse_function_672)
    func61 = _ParseFunction(_ctx._try_SurroundedList, (arg49, T, arg50), ())
    (_status, _result, _pos) = (yield (3, func61, _pos))
    # End Call
    yield (_status, _result, _pos)

def _parse_CurlyList(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_CurlyList, fullparse)

CurlyList = ParsingRule('CurlyList', _parse_CurlyList, """
    CurlyList(T) = SurroundedList('{', T, '}')
""")
def _raise_error670(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'CurlyList' rule, at the expression:\n"
    "    '{'\n\n"
    "Expected to match the string '{'"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error672(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'CurlyList' rule, at the expression:\n"
    "    '}'\n\n"
    "Expected to match the string '}'"
    )
    raise ParseError((title + details), _pos, line, col)

def _parse_function_676(_ctx, _text, _pos):
    # Begin Str
    value81 = '('
    end81 = (_pos + 1)
    if (_text[slice(_pos, end81, None)] == value81):
        _result = value81
        _pos = (yield (3, _ctx._try__ignored, end81))[2]
        _status = True
    else:
        _result = _raise_error676
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_678(_ctx, _text, _pos):
    # Begin Str
    value82 = ')'
    end82 = (_pos + 1)
    if (_text[slice(_pos, end82, None)] == value82):
        _result = value82
        _pos = (yield (3, _ctx._try__ignored, end82))[2]
        _status = True
    else:
        _result = _raise_error678
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_ParenthesesList(_ctx, _text, _pos, T):
    # Rule 'ParenthesesList'
    # Begin Call
    # SurroundedList('(', T, ')')
    arg51 = _wrap_string_literal('(', _parse_function_676)
    arg52 = _wrap_string_literal(')', _parse_function_678)
    func62 = _ParseFunction(_ctx._try_SurroundedList, (arg51, T, arg52), ())
    (_status, _result, _pos) = (yield (3, func62, _pos))
    # End Call
    yield (_status, _result, _pos)

def _parse_ParenthesesList(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_ParenthesesList, fullparse)

ParenthesesList = ParsingRule('ParenthesesList', _parse_ParenthesesList, """
    ParenthesesList(T) = SurroundedList('(', T, ')')
""")
def _raise_error676(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ParenthesesList' rule, at the expression:\n"
    "    '('\n\n"
    "Expected to match the string '('"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error678(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'ParenthesesList' rule, at the expression:\n"
    "    ')'\n\n"
    "Expected to match the string ')'"
    )
    raise ParseError((title + details), _pos, line, col)

def _parse_function_682(_ctx, _text, _pos):
    # Begin Str
    value83 = '['
    end83 = (_pos + 1)
    if (_text[slice(_pos, end83, None)] == value83):
        _result = value83
        _pos = (yield (3, _ctx._try__ignored, end83))[2]
        _status = True
    else:
        _result = _raise_error682
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _parse_function_684(_ctx, _text, _pos):
    # Begin Str
    value84 = ']'
    end84 = (_pos + 1)
    if (_text[slice(_pos, end84, None)] == value84):
        _result = value84
        _pos = (yield (3, _ctx._try__ignored, end84))[2]
        _status = True
    else:
        _result = _raise_error684
        _status = False
    # End Str
    yield (_status, _result, _pos)

def _try_SquareList(_ctx, _text, _pos, T):
    # Rule 'SquareList'
    # Begin Call
    # SurroundedList('[', T, ']')
    arg53 = _wrap_string_literal('[', _parse_function_682)
    arg54 = _wrap_string_literal(']', _parse_function_684)
    func63 = _ParseFunction(_ctx._try_SurroundedList, (arg53, T, arg54), ())
    (_status, _result, _pos) = (yield (3, func63, _pos))
    # End Call
    yield (_status, _result, _pos)

def _parse_SquareList(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try_SquareList, fullparse)

SquareList = ParsingRule('SquareList', _parse_SquareList, """
    SquareList(T) = SurroundedList('[', T, ']')
""")
def _raise_error682(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'SquareList' rule, at the expression:\n"
    "    '['\n\n"
    "Expected to match the string '['"
    )
    raise ParseError((title + details), _pos, line, col)

def _raise_error684(_text, _pos):
    if (len(_text) <= _pos):
        title = 'Unexpected end of input.'
        line = None
        col = None
    else:
        (line, col) = _get_line_and_column(_text, _pos)
        excerpt = _extract_excerpt(_text, _pos, col)
        title = f'Error on line {line}, column {col}:\n{excerpt}\n'
    details = (
    "Failed to parse the 'SquareList' rule, at the expression:\n"
    "    ']'\n\n"
    "Expected to match the string ']'"
    )
    raise ParseError((title + details), _pos, line, col)

def _try__ignored(_ctx, _text, _pos):
    # Rule '_ignored'
    # Begin Skip
    # Skip(Space, Comment, LineExtension)
    while True:
        checkpoint8 = _pos
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Space, _pos))
        # End Ref
        if _status:
            continue
        else:
            _pos = checkpoint8
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_Comment, _pos))
        # End Ref
        if _status:
            continue
        else:
            _pos = checkpoint8
        # Begin Ref
        (_status, _result, _pos) = (yield (3, _ctx._try_LineExtension, _pos))
        # End Ref
        if _status:
            continue
        else:
            _pos = checkpoint8
        break
    _result = None
    _status = True
    # End Skip
    yield (_status, _result, _pos)

def _parse__ignored(text, pos=0, fullparse=True):
    return _run(_ctx, text, pos, _try__ignored, fullparse)

_ignored = ParsingRule('_ignored', _parse__ignored, """
    _ignored = Skip(Space, Comment, LineExtension)
""")
_ctx = _Context()
_ctx._try__ignored = _try__ignored
_ctx._try_Space = _try_Space
_ctx._try_Comment = _try_Comment
_ctx._try_LineExtension = _try_LineExtension
_ctx._try_CheckedSpace = _try_CheckedSpace
_ctx._try_ForbiddenSpace = _try_ForbiddenSpace
_ctx._try_RequiredSpace = _try_RequiredSpace
_ctx._try_Pad = _try_Pad
_ctx._try_wrap = _try_wrap
_ctx._try_Word = _try_Word
_ctx._try_kw = _try_kw
_ctx._try_Name = _try_Name
_ctx._try_start = _try_start
_ctx._try_Definition = _try_Definition
_ctx._try_Class = _try_Class
_ctx._try_Function = _try_Function
_ctx._try_Graph = _try_Graph
_ctx._try_Node = _try_Node
_ctx._try_Template = _try_Template
_ctx._try_AnonymousDefinition = _try_AnonymousDefinition
_ctx._try_Edges = _try_Edges
_ctx._try_ConditionalEdges = _try_ConditionalEdges
_ctx._try_Edge = _try_Edge
_ctx._try_Config = _try_Config
_ctx._try_Handler = _try_Handler
_ctx._try_State = _try_State
_ctx._try_Statement = _try_Statement
_ctx._try_Assign = _try_Assign
_ctx._try_Emit = _try_Emit
_ctx._try_For = _try_For
_ctx._try_Operate = _try_Operate
_ctx._try_Return = _try_Return
_ctx._try_TypeExpression = _try_TypeExpression
_ctx._try_ValueExpression = _try_ValueExpression
_ctx._try_NotIn = _try_NotIn
_ctx._try_LiteralExpression = _try_LiteralExpression
_ctx._try_EmptyMapLiteral = _try_EmptyMapLiteral
_ctx._try_ListLiteral = _try_ListLiteral
_ctx._try_MapLiteral = _try_MapLiteral
_ctx._try_Pair = _try_Pair
_ctx._try_NumberLiteral = _try_NumberLiteral
_ctx._try_SetLiteral = _try_SetLiteral
_ctx._try_SymbolLiteral = _try_SymbolLiteral
_ctx._try_TupleLiteral = _try_TupleLiteral
_ctx._try_ArgumentList = _try_ArgumentList
_ctx._try_GenericArgumentList = _try_GenericArgumentList
_ctx._try_GenericArgument = _try_GenericArgument
_ctx._try_KeywordArgument = _try_KeywordArgument
_ctx._try_KeywordTypeArgument = _try_KeywordTypeArgument
_ctx._try_ElementAccess = _try_ElementAccess
_ctx._try_FieldAccess = _try_FieldAccess
_ctx._try_If = _try_If
_ctx._try_Match = _try_Match
_ctx._try_MatchCase = _try_MatchCase
_ctx._try_Block = _try_Block
_ctx._try_Comma = _try_Comma
_ctx._try_LineSep = _try_LineSep
_ctx._try_Lines = _try_Lines
_ctx._try_Parameter = _try_Parameter
_ctx._try_Names = _try_Names
_ctx._try_SurroundedList = _try_SurroundedList
_ctx._try_CurlyList = _try_CurlyList
_ctx._try_ParenthesesList = _try_ParenthesesList
_ctx._try_SquareList = _try_SquareList
_ctx._try__ignored = _try__ignored
